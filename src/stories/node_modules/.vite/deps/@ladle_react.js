import {
  react_context_default
} from "./chunk-AFTZ5RDY.js";
import {
  useMDXComponents
} from "./chunk-ZEZGCRFH.js";
import {
  empty_module_exports
} from "./chunk-MWDDUFOY.js";
import {
  require_react_dom
} from "./chunk-A3YEUATH.js";
import {
  require_jsx_runtime
} from "./chunk-JELDLQOG.js";
import {
  require_react
} from "./chunk-QV4AIQOX.js";
import {
  __export,
  __toESM
} from "./chunk-G3PMV62Z.js";

// ../../node_modules/@ladle/react/lib/app/src/context.ts
var React = __toESM(require_react(), 1);
var useLadleContext = () => React.useContext(react_context_default);

// ../../node_modules/@ladle/react/lib/shared/types.ts
var ModeState = /* @__PURE__ */ ((ModeState2) => {
  ModeState2["Full"] = "full";
  ModeState2["Preview"] = "preview";
  return ModeState2;
})(ModeState || {});
var ThemeState = /* @__PURE__ */ ((ThemeState2) => {
  ThemeState2["Light"] = "light";
  ThemeState2["Dark"] = "dark";
  ThemeState2["Auto"] = "auto";
  return ThemeState2;
})(ThemeState || {});
var ActionType = /* @__PURE__ */ ((ActionType2) => {
  ActionType2["UpdateAll"] = "update-all";
  ActionType2["UpdateMode"] = "update-mode";
  ActionType2["UpdateAction"] = "update-action";
  ActionType2["UpdateRtl"] = "update-rtl";
  ActionType2["UpdateSource"] = "update-source";
  ActionType2["UpdateStory"] = "update-story";
  ActionType2["UpdateTheme"] = "update-theme";
  ActionType2["UpdateWidth"] = "update-width";
  ActionType2["UpdateControl"] = "update-control";
  ActionType2["UpdateControlIntialized"] = "update-control-initialized";
  ActionType2["UpdateHotkeys"] = "update-hotkeys";
  return ActionType2;
})(ActionType || {});

// ../../node_modules/@ladle/react/lib/app/src/ui.tsx
var ui_exports = {};
__export(ui_exports, {
  Button: () => Button,
  Code: () => Code,
  Link: () => Link,
  Modal: () => Modal
});

// ../../node_modules/@ladle/react/lib/app/src/dialog.tsx
var dialog_exports = {};
__export(dialog_exports, {
  Dialog: () => Dialog,
  DialogContent: () => DialogContent,
  DialogOverlay: () => DialogOverlay,
  default: () => dialog_default
});
var react = __toESM(require_react(), 1);
var reactDom = __toESM(require_react_dom(), 1);
function _extends$1() {
  _extends = Object.assign || function(target) {
    for (let i = 1; i < arguments.length; i++) {
      const source = arguments[i];
      for (const key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function createCommonjsModule(fn, basedir, module) {
  return module = {
    path: basedir,
    exports: {},
    require: function(path, base) {
      return commonjsRequire(
        path,
        base === void 0 || base === null ? module.path : base
      );
    }
  }, fn(module, module.exports), module.exports;
}
function commonjsRequire() {
  throw new Error(
    "Dynamic requires are not currently supported by @rollup/plugin-commonjs"
  );
}
function defaultSetTimout() {
  throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
  throw new Error("clearTimeout has not been defined");
}
var cachedSetTimeout = defaultSetTimout;
var cachedClearTimeout = defaultClearTimeout;
var globalContext;
if (typeof window !== "undefined") {
  globalContext = window;
} else if (typeof self !== "undefined") {
  globalContext = self;
} else {
  globalContext = {};
}
if (typeof globalContext.setTimeout === "function") {
  cachedSetTimeout = setTimeout;
}
if (typeof globalContext.clearTimeout === "function") {
  cachedClearTimeout = clearTimeout;
}
function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    return setTimeout(fun, 0);
  }
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }
  try {
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e2) {
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}
function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    return clearTimeout(marker);
  }
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }
  try {
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      return cachedClearTimeout.call(null, marker);
    } catch (e2) {
      return cachedClearTimeout.call(this, marker);
    }
  }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;
function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }
  draining = false;
  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }
  if (queue.length) {
    drainQueue();
  }
}
function drainQueue() {
  if (draining) {
    return;
  }
  const timeout = runTimeout(cleanUpNextTick);
  draining = true;
  let len = queue.length;
  while (len) {
    currentQueue = queue;
    queue = [];
    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }
    queueIndex = -1;
    len = queue.length;
  }
  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}
function nextTick(fun) {
  const args = new Array(arguments.length - 1);
  if (arguments.length > 1) {
    for (let i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }
  queue.push(new Item(fun, args));
  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
}
function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}
Item.prototype.run = function() {
  this.fun.apply(null, this.array);
};
var title = "browser";
var platform = "browser";
var browser = true;
var argv = [];
var version = "";
var versions = {};
var release = {};
var config = {};
function noop() {
}
var on = noop;
var addListener = noop;
var once = noop;
var off = noop;
var removeListener = noop;
var removeAllListeners = noop;
var emit = noop;
function binding(name) {
  throw new Error("process.binding is not supported");
}
function cwd() {
  return "/";
}
function chdir(dir) {
  throw new Error("process.chdir is not supported");
}
function umask() {
  return 0;
}
var performance = globalContext.performance || {};
var performanceNow = performance.now || performance.mozNow || performance.msNow || performance.oNow || performance.webkitNow || function() {
  return (/* @__PURE__ */ new Date()).getTime();
};
function hrtime(previousTimestamp) {
  const clocktime = performanceNow.call(performance) * 1e-3;
  let seconds = Math.floor(clocktime);
  let nanoseconds = Math.floor(clocktime % 1 * 1e9);
  if (previousTimestamp) {
    seconds = seconds - previousTimestamp[0];
    nanoseconds = nanoseconds - previousTimestamp[1];
    if (nanoseconds < 0) {
      seconds--;
      nanoseconds += 1e9;
    }
  }
  return [seconds, nanoseconds];
}
var startTime = /* @__PURE__ */ new Date();
function uptime() {
  const currentTime = /* @__PURE__ */ new Date();
  const dif = currentTime - startTime;
  return dif / 1e3;
}
var process = {
  nextTick,
  title,
  browser,
  env: { NODE_ENV: "development" },
  argv,
  version,
  versions,
  on,
  addListener,
  once,
  off,
  removeListener,
  removeAllListeners,
  emit,
  binding,
  cwd,
  chdir,
  umask,
  hrtime,
  platform,
  release,
  config,
  uptime
};
var objectAssign = function(target, source) {
  let from;
  const to = toObject(target);
  let symbols;
  for (let s = 1; s < arguments.length; s++) {
    from = Object(arguments[s]);
    for (const key in from) {
      if (hasOwnProperty.call(from, key)) {
        to[key] = from[key];
      }
    }
    if (getOwnPropertySymbols) {
      symbols = getOwnPropertySymbols(from);
      for (let i = 0; i < symbols.length; i++) {
        if (propIsEnumerable.call(from, symbols[i])) {
          to[symbols[i]] = from[symbols[i]];
        }
      }
    }
  }
  return to;
};
var useIsomorphicLayoutEffect = canUseDOM() ? react.useLayoutEffect : react.useEffect;
var checkedPkgs = {};
var checkStyles = noop;
{
  const _ref$1 = typeof process !== "undefined" ? process : {
    env: {
      NODE_ENV: "development"
    }
  }, env = _ref$1.env;
  checkStyles = function checkStyles2(packageName) {
    if (checkedPkgs[packageName]) return;
    checkedPkgs[packageName] = true;
  };
}
function assignRef$1(ref, value) {
  if (ref == null) return;
  if (isFunction(ref)) {
    ref(value);
  } else {
    try {
      ref.current = value;
    } catch (error) {
      throw new Error(
        'Cannot assign value "' + value + '" to ref "' + ref + '"'
      );
    }
  }
}
function canUseDOM() {
  return !!(typeof window !== "undefined" && window.document && window.document.createElement);
}
function forwardRefWithAs(render) {
  return react.forwardRef(render);
}
function getOwnerDocument(element) {
  return canUseDOM() ? element ? element.ownerDocument : document : null;
}
function isFunction(value) {
  return !!(value && {}.toString.call(value) == "[object Function]");
}
function isString(value) {
  return typeof value === "string";
}
var useCheckStyles = noop;
{
  useCheckStyles = function useCheckStyles2(pkg) {
    const name = react.useRef(pkg);
    react.useEffect(
      function() {
        return void (name.current = pkg);
      },
      [pkg]
    );
    react.useEffect(function() {
      return checkStyles(name.current);
    }, []);
  };
}
function useForceUpdate() {
  const _React$useState2 = react.useState(/* @__PURE__ */ Object.create(null)), dispatch = _React$useState2[1];
  return react.useCallback(function() {
    dispatch(/* @__PURE__ */ Object.create(null));
  }, []);
}
function useForkedRef() {
  for (var _len4 = arguments.length, refs = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
    refs[_key4] = arguments[_key4];
  }
  return react.useMemo(function() {
    if (refs.every(function(ref) {
      return ref == null;
    })) {
      return null;
    }
    return function(node) {
      refs.forEach(function(ref) {
        assignRef$1(ref, node);
      });
    };
  }, [].concat(refs));
}
function wrapEvent(theirHandler, ourHandler) {
  return function(event) {
    theirHandler && theirHandler(event);
    if (!event.defaultPrevented) {
      return ourHandler(event);
    }
  };
}
var Portal = function Portal2(_ref2) {
  const children = _ref2.children, _ref$type = _ref2.type, type = _ref$type === void 0 ? "reach-portal" : _ref$type;
  const mountNode = react.useRef(null);
  const portalNode = react.useRef(null);
  const forceUpdate = useForceUpdate();
  useIsomorphicLayoutEffect(
    function() {
      if (!mountNode.current) return;
      const ownerDocument = mountNode.current.ownerDocument;
      portalNode.current = ownerDocument == null ? void 0 : ownerDocument.createElement(type);
      ownerDocument.body.appendChild(portalNode.current);
      forceUpdate();
      return function() {
        if (portalNode.current && portalNode.current.ownerDocument) {
          portalNode.current.ownerDocument.body.removeChild(portalNode.current);
        }
      };
    },
    [type, forceUpdate]
  );
  return portalNode.current ? reactDom.createPortal(children, portalNode.current) : react.createElement("span", {
    ref: mountNode
  });
};
{
  Portal.displayName = "Portal";
}
function _objectWithoutPropertiesLoose$1(source, excluded) {
  if (source == null) return {};
  const target = {};
  const sourceKeys = Object.keys(source);
  let key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var reactIs_development = createCommonjsModule(function(module, exports) {
  {
    (function() {
      const hasSymbol = typeof Symbol === "function" && Symbol.for;
      const REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 60103;
      const REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106;
      const REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 60107;
      const REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for("react.strict_mode") : 60108;
      const REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 60114;
      const REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 60109;
      const REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 60110;
      const REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for("react.async_mode") : 60111;
      const REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for("react.concurrent_mode") : 60111;
      const REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 60112;
      const REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113;
      const REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for("react.suspense_list") : 60120;
      const REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115;
      const REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116;
      const REACT_BLOCK_TYPE = hasSymbol ? Symbol.for("react.block") : 60121;
      const REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for("react.fundamental") : 60117;
      const REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for("react.responder") : 60118;
      const REACT_SCOPE_TYPE = hasSymbol ? Symbol.for("react.scope") : 60119;
      function isValidElementType(type) {
        return typeof type === "string" || typeof type === "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
        type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
      }
      function typeOf(object) {
        if (typeof object === "object" && object !== null) {
          const $$typeof = object.$$typeof;
          switch ($$typeof) {
            case REACT_ELEMENT_TYPE:
              var type = object.type;
              switch (type) {
                case REACT_ASYNC_MODE_TYPE:
                case REACT_CONCURRENT_MODE_TYPE:
                case REACT_FRAGMENT_TYPE:
                case REACT_PROFILER_TYPE:
                case REACT_STRICT_MODE_TYPE:
                case REACT_SUSPENSE_TYPE:
                  return type;
                default:
                  var $$typeofType = type && type.$$typeof;
                  switch ($$typeofType) {
                    case REACT_CONTEXT_TYPE:
                    case REACT_FORWARD_REF_TYPE:
                    case REACT_LAZY_TYPE:
                    case REACT_MEMO_TYPE:
                    case REACT_PROVIDER_TYPE:
                      return $$typeofType;
                    default:
                      return $$typeof;
                  }
              }
            case REACT_PORTAL_TYPE:
              return $$typeof;
          }
        }
        return void 0;
      }
      const AsyncMode = REACT_ASYNC_MODE_TYPE;
      const ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
      const ContextConsumer = REACT_CONTEXT_TYPE;
      const ContextProvider = REACT_PROVIDER_TYPE;
      const Element = REACT_ELEMENT_TYPE;
      const ForwardRef = REACT_FORWARD_REF_TYPE;
      const Fragment2 = REACT_FRAGMENT_TYPE;
      const Lazy = REACT_LAZY_TYPE;
      const Memo = REACT_MEMO_TYPE;
      const Portal3 = REACT_PORTAL_TYPE;
      const Profiler = REACT_PROFILER_TYPE;
      const StrictMode = REACT_STRICT_MODE_TYPE;
      const Suspense = REACT_SUSPENSE_TYPE;
      let hasWarnedAboutDeprecatedIsAsyncMode = false;
      function isAsyncMode(object) {
        {
          if (!hasWarnedAboutDeprecatedIsAsyncMode) {
            hasWarnedAboutDeprecatedIsAsyncMode = true;
            console["warn"](
              "The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API."
            );
          }
        }
        return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
      }
      function isConcurrentMode(object) {
        return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
      }
      function isContextConsumer(object) {
        return typeOf(object) === REACT_CONTEXT_TYPE;
      }
      function isContextProvider(object) {
        return typeOf(object) === REACT_PROVIDER_TYPE;
      }
      function isElement(object) {
        return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
      }
      function isForwardRef(object) {
        return typeOf(object) === REACT_FORWARD_REF_TYPE;
      }
      function isFragment(object) {
        return typeOf(object) === REACT_FRAGMENT_TYPE;
      }
      function isLazy(object) {
        return typeOf(object) === REACT_LAZY_TYPE;
      }
      function isMemo(object) {
        return typeOf(object) === REACT_MEMO_TYPE;
      }
      function isPortal(object) {
        return typeOf(object) === REACT_PORTAL_TYPE;
      }
      function isProfiler(object) {
        return typeOf(object) === REACT_PROFILER_TYPE;
      }
      function isStrictMode(object) {
        return typeOf(object) === REACT_STRICT_MODE_TYPE;
      }
      function isSuspense(object) {
        return typeOf(object) === REACT_SUSPENSE_TYPE;
      }
      exports.AsyncMode = AsyncMode;
      exports.ConcurrentMode = ConcurrentMode;
      exports.ContextConsumer = ContextConsumer;
      exports.ContextProvider = ContextProvider;
      exports.Element = Element;
      exports.ForwardRef = ForwardRef;
      exports.Fragment = Fragment2;
      exports.Lazy = Lazy;
      exports.Memo = Memo;
      exports.Portal = Portal3;
      exports.Profiler = Profiler;
      exports.StrictMode = StrictMode;
      exports.Suspense = Suspense;
      exports.isAsyncMode = isAsyncMode;
      exports.isConcurrentMode = isConcurrentMode;
      exports.isContextConsumer = isContextConsumer;
      exports.isContextProvider = isContextProvider;
      exports.isElement = isElement;
      exports.isForwardRef = isForwardRef;
      exports.isFragment = isFragment;
      exports.isLazy = isLazy;
      exports.isMemo = isMemo;
      exports.isPortal = isPortal;
      exports.isProfiler = isProfiler;
      exports.isStrictMode = isStrictMode;
      exports.isSuspense = isSuspense;
      exports.isValidElementType = isValidElementType;
      exports.typeOf = typeOf;
    })();
  }
});
var reactIs = createCommonjsModule(function(module) {
  {
    module.exports = reactIs_development;
  }
});
var ReactPropTypesSecret$1 = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
var ReactPropTypesSecret_1 = ReactPropTypesSecret$1;
var printWarning$1 = function() {
};
{
  ReactPropTypesSecret = ReactPropTypesSecret_1;
  loggedTypeFailures = {};
  has$1 = Function.call.bind(Object.prototype.hasOwnProperty);
  printWarning$1 = function(text) {
    const message = "Warning: " + text;
    if (typeof console !== "undefined") {
      console.error(message);
    }
    try {
      throw new Error(message);
    } catch (x) {
    }
  };
}
var ReactPropTypesSecret;
var loggedTypeFailures;
var has$1;
function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
  {
    for (const typeSpecName in typeSpecs) {
      if (has$1(typeSpecs, typeSpecName)) {
        var error;
        try {
          if (typeof typeSpecs[typeSpecName] !== "function") {
            const err = Error(
              (componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`."
            );
            err.name = "Invariant Violation";
            throw err;
          }
          error = typeSpecs[typeSpecName](
            values,
            typeSpecName,
            componentName,
            location,
            null,
            ReactPropTypesSecret
          );
        } catch (ex) {
          error = ex;
        }
        if (error && !(error instanceof Error)) {
          printWarning$1(
            (componentName || "React class") + ": type specification of " + location + " `" + typeSpecName + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof error + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          );
        }
        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
          loggedTypeFailures[error.message] = true;
          const stack = getStack ? getStack() : "";
          printWarning$1(
            "Failed " + location + " type: " + error.message + (stack != null ? stack : "")
          );
        }
      }
    }
  }
}
checkPropTypes.resetWarningCache = function() {
  {
    loggedTypeFailures = {};
  }
};
var checkPropTypes_1 = checkPropTypes;
var has = Function.call.bind(Object.prototype.hasOwnProperty);
var printWarning = function() {
};
{
  printWarning = function(text) {
    const message = "Warning: " + text;
    if (typeof console !== "undefined") {
      console.error(message);
    }
    try {
      throw new Error(message);
    } catch (x) {
    }
  };
}
function emptyFunctionThatReturnsNull() {
  return null;
}
var factoryWithTypeCheckers = function(isValidElement, throwOnDirectAccess) {
  const ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
  const FAUX_ITERATOR_SYMBOL = "@@iterator";
  function getIteratorFn(maybeIterable) {
    const iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
    if (typeof iteratorFn === "function") {
      return iteratorFn;
    }
  }
  const ANONYMOUS = "<<anonymous>>";
  const ReactPropTypes = {
    array: createPrimitiveTypeChecker("array"),
    bool: createPrimitiveTypeChecker("boolean"),
    func: createPrimitiveTypeChecker("function"),
    number: createPrimitiveTypeChecker("number"),
    object: createPrimitiveTypeChecker("object"),
    string: createPrimitiveTypeChecker("string"),
    symbol: createPrimitiveTypeChecker("symbol"),
    any: createAnyTypeChecker(),
    arrayOf: createArrayOfTypeChecker,
    element: createElementTypeChecker(),
    elementType: createElementTypeTypeChecker(),
    instanceOf: createInstanceTypeChecker,
    node: createNodeChecker(),
    objectOf: createObjectOfTypeChecker,
    oneOf: createEnumTypeChecker,
    oneOfType: createUnionTypeChecker,
    shape: createShapeTypeChecker,
    exact: createStrictShapeTypeChecker
  };
  function is(x, y) {
    if (x === y) {
      return x !== 0 || 1 / x === 1 / y;
    } else {
      return x !== x && y !== y;
    }
  }
  function PropTypeError(message) {
    this.message = message;
    this.stack = "";
  }
  PropTypeError.prototype = Error.prototype;
  function createChainableTypeChecker(validate) {
    {
      var manualPropTypeCallCache = {};
      var manualPropTypeWarningCount = 0;
    }
    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
      componentName = componentName || ANONYMOUS;
      propFullName = propFullName || propName;
      if (secret !== ReactPropTypesSecret_1) {
        if (throwOnDirectAccess) {
          const err = new Error(
            "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
          );
          err.name = "Invariant Violation";
          throw err;
        } else if (typeof console !== "undefined") {
          const cacheKey = componentName + ":" + propName;
          if (!manualPropTypeCallCache[cacheKey] && // Avoid spamming the console because they are often not actionable except for lib authors
          manualPropTypeWarningCount < 3) {
            printWarning(
              "You are manually calling a React.PropTypes validation function for the `" + propFullName + "` prop on `" + componentName + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            );
            manualPropTypeCallCache[cacheKey] = true;
            manualPropTypeWarningCount++;
          }
        }
      }
      if (props[propName] == null) {
        if (isRequired) {
          if (props[propName] === null) {
            return new PropTypeError(
              "The " + location + " `" + propFullName + "` is marked as required " + ("in `" + componentName + "`, but its value is `null`.")
            );
          }
          return new PropTypeError(
            "The " + location + " `" + propFullName + "` is marked as required in " + ("`" + componentName + "`, but its value is `undefined`.")
          );
        }
        return null;
      } else {
        return validate(props, propName, componentName, location, propFullName);
      }
    }
    const chainedCheckType = checkType.bind(null, false);
    chainedCheckType.isRequired = checkType.bind(null, true);
    return chainedCheckType;
  }
  function createPrimitiveTypeChecker(expectedType) {
    function validate(props, propName, componentName, location, propFullName, secret) {
      const propValue = props[propName];
      const propType = getPropType(propValue);
      if (propType !== expectedType) {
        const preciseType = getPreciseType(propValue);
        return new PropTypeError(
          "Invalid " + location + " `" + propFullName + "` of type " + ("`" + preciseType + "` supplied to `" + componentName + "`, expected ") + ("`" + expectedType + "`.")
        );
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }
  function createAnyTypeChecker() {
    return createChainableTypeChecker(emptyFunctionThatReturnsNull);
  }
  function createArrayOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== "function") {
        return new PropTypeError(
          "Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside arrayOf."
        );
      }
      const propValue = props[propName];
      if (!Array.isArray(propValue)) {
        const propType = getPropType(propValue);
        return new PropTypeError(
          "Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an array.")
        );
      }
      for (let i = 0; i < propValue.length; i++) {
        const error = typeChecker(
          propValue,
          i,
          componentName,
          location,
          propFullName + "[" + i + "]",
          ReactPropTypesSecret_1
        );
        if (error instanceof Error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }
  function createElementTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      const propValue = props[propName];
      if (!isValidElement(propValue)) {
        const propType = getPropType(propValue);
        return new PropTypeError(
          "Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement.")
        );
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }
  function createElementTypeTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      const propValue = props[propName];
      if (!reactIs.isValidElementType(propValue)) {
        const propType = getPropType(propValue);
        return new PropTypeError(
          "Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement type.")
        );
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }
  function createInstanceTypeChecker(expectedClass) {
    function validate(props, propName, componentName, location, propFullName) {
      if (!(props[propName] instanceof expectedClass)) {
        const expectedClassName = expectedClass.name || ANONYMOUS;
        const actualClassName = getClassName(props[propName]);
        return new PropTypeError(
          "Invalid " + location + " `" + propFullName + "` of type " + ("`" + actualClassName + "` supplied to `" + componentName + "`, expected ") + ("instance of `" + expectedClassName + "`.")
        );
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }
  function createEnumTypeChecker(expectedValues) {
    if (!Array.isArray(expectedValues)) {
      {
        if (arguments.length > 1) {
          printWarning(
            "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
          );
        } else {
          printWarning(
            "Invalid argument supplied to oneOf, expected an array."
          );
        }
      }
      return emptyFunctionThatReturnsNull;
    }
    function validate(props, propName, componentName, location, propFullName) {
      const propValue = props[propName];
      for (let i = 0; i < expectedValues.length; i++) {
        if (is(propValue, expectedValues[i])) {
          return null;
        }
      }
      const valuesString = JSON.stringify(
        expectedValues,
        function replacer(key, value) {
          const type = getPreciseType(value);
          if (type === "symbol") {
            return String(value);
          }
          return value;
        }
      );
      return new PropTypeError(
        "Invalid " + location + " `" + propFullName + "` of value `" + String(propValue) + "` " + ("supplied to `" + componentName + "`, expected one of " + valuesString + ".")
      );
    }
    return createChainableTypeChecker(validate);
  }
  function createObjectOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== "function") {
        return new PropTypeError(
          "Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside objectOf."
        );
      }
      const propValue = props[propName];
      const propType = getPropType(propValue);
      if (propType !== "object") {
        return new PropTypeError(
          "Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an object.")
        );
      }
      for (const key in propValue) {
        if (has(propValue, key)) {
          const error = typeChecker(
            propValue,
            key,
            componentName,
            location,
            propFullName + "." + key,
            ReactPropTypesSecret_1
          );
          if (error instanceof Error) {
            return error;
          }
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }
  function createUnionTypeChecker(arrayOfTypeCheckers) {
    if (!Array.isArray(arrayOfTypeCheckers)) {
      printWarning(
        "Invalid argument supplied to oneOfType, expected an instance of array."
      );
      return emptyFunctionThatReturnsNull;
    }
    for (let i = 0; i < arrayOfTypeCheckers.length; i++) {
      const checker = arrayOfTypeCheckers[i];
      if (typeof checker !== "function") {
        printWarning(
          "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + getPostfixForTypeWarning(checker) + " at index " + i + "."
        );
        return emptyFunctionThatReturnsNull;
      }
    }
    function validate(props, propName, componentName, location, propFullName) {
      for (let i = 0; i < arrayOfTypeCheckers.length; i++) {
        const checker = arrayOfTypeCheckers[i];
        if (checker(
          props,
          propName,
          componentName,
          location,
          propFullName,
          ReactPropTypesSecret_1
        ) == null) {
          return null;
        }
      }
      return new PropTypeError(
        "Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`.")
      );
    }
    return createChainableTypeChecker(validate);
  }
  function createNodeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      if (!isNode(props[propName])) {
        return new PropTypeError(
          "Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`, expected a ReactNode.")
        );
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }
  function createShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      const propValue = props[propName];
      const propType = getPropType(propValue);
      if (propType !== "object") {
        return new PropTypeError(
          "Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`.")
        );
      }
      for (const key in shapeTypes) {
        const checker = shapeTypes[key];
        if (!checker) {
          continue;
        }
        const error = checker(
          propValue,
          key,
          componentName,
          location,
          propFullName + "." + key,
          ReactPropTypesSecret_1
        );
        if (error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }
  function createStrictShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      const propValue = props[propName];
      const propType = getPropType(propValue);
      if (propType !== "object") {
        return new PropTypeError(
          "Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`.")
        );
      }
      const allKeys = objectAssign({}, props[propName], shapeTypes);
      for (const key in allKeys) {
        const checker = shapeTypes[key];
        if (!checker) {
          return new PropTypeError(
            "Invalid " + location + " `" + propFullName + "` key `" + key + "` supplied to `" + componentName + "`.\nBad object: " + JSON.stringify(props[propName], null, "  ") + "\nValid keys: " + JSON.stringify(Object.keys(shapeTypes), null, "  ")
          );
        }
        const error = checker(
          propValue,
          key,
          componentName,
          location,
          propFullName + "." + key,
          ReactPropTypesSecret_1
        );
        if (error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }
  function isNode(propValue) {
    switch (typeof propValue) {
      case "number":
      case "string":
      case "undefined":
        return true;
      case "boolean":
        return !propValue;
      case "object":
        if (Array.isArray(propValue)) {
          return propValue.every(isNode);
        }
        if (propValue === null || isValidElement(propValue)) {
          return true;
        }
        var iteratorFn = getIteratorFn(propValue);
        if (iteratorFn) {
          const iterator = iteratorFn.call(propValue);
          let step;
          if (iteratorFn !== propValue.entries) {
            while (!(step = iterator.next()).done) {
              if (!isNode(step.value)) {
                return false;
              }
            }
          } else {
            while (!(step = iterator.next()).done) {
              const entry = step.value;
              if (entry) {
                if (!isNode(entry[1])) {
                  return false;
                }
              }
            }
          }
        } else {
          return false;
        }
        return true;
      default:
        return false;
    }
  }
  function isSymbol(propType, propValue) {
    if (propType === "symbol") {
      return true;
    }
    if (!propValue) {
      return false;
    }
    if (propValue["@@toStringTag"] === "Symbol") {
      return true;
    }
    if (typeof Symbol === "function" && propValue instanceof Symbol) {
      return true;
    }
    return false;
  }
  function getPropType(propValue) {
    const propType = typeof propValue;
    if (Array.isArray(propValue)) {
      return "array";
    }
    if (propValue instanceof RegExp) {
      return "object";
    }
    if (isSymbol(propType, propValue)) {
      return "symbol";
    }
    return propType;
  }
  function getPreciseType(propValue) {
    if (typeof propValue === "undefined" || propValue === null) {
      return "" + propValue;
    }
    const propType = getPropType(propValue);
    if (propType === "object") {
      if (propValue instanceof Date) {
        return "date";
      } else if (propValue instanceof RegExp) {
        return "regexp";
      }
    }
    return propType;
  }
  function getPostfixForTypeWarning(value) {
    const type = getPreciseType(value);
    switch (type) {
      case "array":
      case "object":
        return "an " + type;
      case "boolean":
      case "date":
      case "regexp":
        return "a " + type;
      default:
        return type;
    }
  }
  function getClassName(propValue) {
    if (!propValue.constructor || !propValue.constructor.name) {
      return ANONYMOUS;
    }
    return propValue.constructor.name;
  }
  ReactPropTypes.checkPropTypes = checkPropTypes_1;
  ReactPropTypes.resetWarningCache = checkPropTypes_1.resetWarningCache;
  ReactPropTypes.PropTypes = ReactPropTypes;
  return ReactPropTypes;
};
var propTypes$1 = createCommonjsModule(function(module) {
  {
    const ReactIs = reactIs;
    const throwOnDirectAccess = true;
    module.exports = factoryWithTypeCheckers(
      ReactIs.isElement,
      throwOnDirectAccess
    );
  }
});
var FOCUS_GROUP = "data-focus-lock";
var FOCUS_DISABLED = "data-focus-lock-disabled";
var FOCUS_ALLOW = "data-no-focus-lock";
var FOCUS_AUTO = "data-autofocus-inside";
function assignRef(ref, value) {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref) {
    ref.current = value;
  }
  return ref;
}
function useCallbackRef(initialValue, callback) {
  var ref = react.useState(function() {
    return {
      // value
      value: initialValue,
      // last callback
      callback,
      // "memoized" public interface
      facade: {
        get current() {
          return ref.value;
        },
        set current(value) {
          const last = ref.value;
          if (last !== value) {
            ref.value = value;
            ref.callback(value, last);
          }
        }
      }
    };
  })[0];
  ref.callback = callback;
  return ref.facade;
}
function useMergeRefs(refs, defaultValue) {
  return useCallbackRef(defaultValue, function(newValue) {
    return refs.forEach(function(ref) {
      return assignRef(ref, newValue);
    });
  });
}
var hiddenGuard = {
  width: "1px",
  height: "0px",
  padding: 0,
  overflow: "hidden",
  position: "fixed",
  top: "1px",
  left: "1px"
};
({
  children: propTypes$1.node
});
var __assign$1 = function() {
  __assign$1 = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (const p in s)
        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign$1.apply(this, arguments);
};
function __rest$1(s, e) {
  const t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function ItoI(a) {
  return a;
}
function innerCreateMedium(defaults, middleware) {
  if (middleware === void 0) {
    middleware = ItoI;
  }
  let buffer = [];
  let assigned = false;
  const medium = {
    read: function() {
      if (assigned) {
        throw new Error(
          "Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`."
        );
      }
      if (buffer.length) {
        return buffer[buffer.length - 1];
      }
      return defaults;
    },
    useMedium: function(data) {
      const item = middleware(data, assigned);
      buffer.push(item);
      return function() {
        buffer = buffer.filter(function(x) {
          return x !== item;
        });
      };
    },
    assignSyncMedium: function(cb) {
      assigned = true;
      while (buffer.length) {
        const cbs = buffer;
        buffer = [];
        cbs.forEach(cb);
      }
      buffer = {
        push: function(x) {
          return cb(x);
        },
        filter: function() {
          return buffer;
        }
      };
    },
    assignMedium: function(cb) {
      assigned = true;
      let pendingQueue = [];
      if (buffer.length) {
        const cbs = buffer;
        buffer = [];
        cbs.forEach(cb);
        pendingQueue = buffer;
      }
      const executeQueue = function() {
        const cbs = pendingQueue;
        pendingQueue = [];
        cbs.forEach(cb);
      };
      const cycle = function() {
        return Promise.resolve().then(executeQueue);
      };
      cycle();
      buffer = {
        push: function(x) {
          pendingQueue.push(x);
          cycle();
        },
        filter: function(filter) {
          pendingQueue = pendingQueue.filter(filter);
          return buffer;
        }
      };
    }
  };
  return medium;
}
function createMedium(defaults, middleware) {
  if (middleware === void 0) {
    middleware = ItoI;
  }
  return innerCreateMedium(defaults, middleware);
}
function createSidecarMedium(options) {
  if (options === void 0) {
    options = {};
  }
  const medium = innerCreateMedium(null);
  medium.options = __assign$1({ async: true, ssr: false }, options);
  return medium;
}
var SideCar$1 = function(_a) {
  const sideCar = _a.sideCar, rest = __rest$1(_a, ["sideCar"]);
  if (!sideCar) {
    throw new Error(
      "Sidecar: please provide `sideCar` property to import the right car"
    );
  }
  const Target = sideCar.read();
  if (!Target) {
    throw new Error("Sidecar medium not found");
  }
  return react.createElement(Target, __assign$1({}, rest));
};
SideCar$1.isSideCarExport = true;
function exportSidecar(medium, exported) {
  medium.useMedium(exported);
  return SideCar$1;
}
var mediumFocus = createMedium({}, function(_ref2) {
  const target = _ref2.target, currentTarget = _ref2.currentTarget;
  return {
    target,
    currentTarget
  };
});
var mediumBlur = createMedium();
var mediumEffect = createMedium();
var mediumSidecar = createSidecarMedium({
  async: true
});
var emptyArray = [];
var FocusLock = react.forwardRef(
  function FocusLockUI(props, parentRef) {
    let _extends2;
    const _React$useState = react.useState(), realObserved = _React$useState[0], setObserved = _React$useState[1];
    const observed = react.useRef();
    const isActive = react.useRef(false);
    const originalFocusedElement = react.useRef(null);
    const children = props.children, disabled = props.disabled, noFocusGuards = props.noFocusGuards, persistentFocus = props.persistentFocus, crossFrame = props.crossFrame, autoFocus = props.autoFocus, allowTextSelection = props.allowTextSelection, group = props.group, className = props.className, whiteList = props.whiteList, _props$shards = props.shards, shards = _props$shards === void 0 ? emptyArray : _props$shards, _props$as = props.as, Container = _props$as === void 0 ? "div" : _props$as, _props$lockProps = props.lockProps, containerProps = _props$lockProps === void 0 ? {} : _props$lockProps, SideCar2 = props.sideCar, shouldReturnFocus = props.returnFocus, onActivationCallback = props.onActivation, onDeactivationCallback = props.onDeactivation;
    const _React$useState2 = react.useState({}), id = _React$useState2[0];
    const onActivation = react.useCallback(
      function() {
        originalFocusedElement.current = originalFocusedElement.current || document && document.activeElement;
        if (observed.current && onActivationCallback) {
          onActivationCallback(observed.current);
        }
        isActive.current = true;
      },
      [onActivationCallback]
    );
    const onDeactivation = react.useCallback(
      function() {
        isActive.current = false;
        if (onDeactivationCallback) {
          onDeactivationCallback(observed.current);
        }
      },
      [onDeactivationCallback]
    );
    const returnFocus = react.useCallback(
      function(allowDefer) {
        const current = originalFocusedElement.current;
        if (Boolean(shouldReturnFocus) && current && current.focus) {
          const focusOptions = typeof shouldReturnFocus === "object" ? shouldReturnFocus : void 0;
          originalFocusedElement.current = null;
          if (allowDefer) {
            Promise.resolve().then(function() {
              return current.focus(focusOptions);
            });
          } else {
            current.focus(focusOptions);
          }
        }
      },
      [shouldReturnFocus]
    );
    const onFocus3 = react.useCallback(function(event) {
      if (isActive.current) {
        mediumFocus.useMedium(event);
      }
    }, []);
    const onBlur3 = mediumBlur.useMedium;
    const setObserveNode = react.useCallback(function(newObserved) {
      if (observed.current !== newObserved) {
        observed.current = newObserved;
        setObserved(newObserved);
      }
    }, []);
    {
      if (typeof allowTextSelection !== "undefined") {
        console.warn(
          "React-Focus-Lock: allowTextSelection is deprecated and enabled by default"
        );
      }
      react.useEffect(function() {
        if (!observed.current) {
          console.error("FocusLock: could not obtain ref to internal node");
        }
      }, []);
    }
    const lockProps = _extends$1(
      (_extends2 = {}, _extends2[FOCUS_DISABLED] = disabled && "disabled", _extends2[FOCUS_GROUP] = group, _extends2),
      containerProps
    );
    const hasLeadingGuards = noFocusGuards !== true;
    const hasTailingGuards = hasLeadingGuards && noFocusGuards !== "tail";
    const mergedRef = useMergeRefs([parentRef, setObserveNode]);
    return react.createElement(
      react.Fragment,
      null,
      hasLeadingGuards && [
        react.createElement("div", {
          key: "guard-first",
          "data-focus-guard": true,
          tabIndex: disabled ? -1 : 0,
          style: hiddenGuard
        }),
        // nearest focus guard
        react.createElement("div", {
          key: "guard-nearest",
          "data-focus-guard": true,
          tabIndex: disabled ? -1 : 1,
          style: hiddenGuard
        })
        // first tabbed element guard
      ],
      !disabled && react.createElement(SideCar2, {
        id,
        sideCar: mediumSidecar,
        observed: realObserved,
        disabled,
        persistentFocus,
        crossFrame,
        autoFocus,
        whiteList,
        shards,
        onActivation,
        onDeactivation,
        returnFocus
      }),
      react.createElement(
        Container,
        _extends$1(
          {
            ref: mergedRef
          },
          lockProps,
          {
            className,
            onBlur: onBlur3,
            onFocus: onFocus3
          }
        ),
        children
      ),
      hasTailingGuards && react.createElement("div", {
        "data-focus-guard": true,
        tabIndex: disabled ? -1 : 0,
        style: hiddenGuard
      })
    );
  }
);
FocusLock.propTypes = {
  children: propTypes$1.node,
  disabled: propTypes$1.bool,
  returnFocus: propTypes$1.oneOfType([propTypes$1.bool, propTypes$1.object]),
  noFocusGuards: propTypes$1.bool,
  allowTextSelection: propTypes$1.bool,
  autoFocus: propTypes$1.bool,
  persistentFocus: propTypes$1.bool,
  crossFrame: propTypes$1.bool,
  group: propTypes$1.string,
  className: propTypes$1.string,
  whiteList: propTypes$1.func,
  shards: propTypes$1.arrayOf(propTypes$1.any),
  as: propTypes$1.oneOfType([
    propTypes$1.string,
    propTypes$1.func,
    propTypes$1.object
  ]),
  lockProps: propTypes$1.object,
  onActivation: propTypes$1.func,
  onDeactivation: propTypes$1.func,
  sideCar: propTypes$1.any.isRequired
};
FocusLock.defaultProps = {
  children: void 0,
  disabled: false,
  returnFocus: false,
  noFocusGuards: false,
  autoFocus: true,
  persistentFocus: false,
  crossFrame: true,
  allowTextSelection: void 0,
  group: void 0,
  className: void 0,
  whiteList: void 0,
  shards: void 0,
  as: "div",
  lockProps: {},
  onActivation: void 0,
  onDeactivation: void 0
};
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf(o, p);
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function withSideEffect(reducePropsToState2, handleStateChangeOnClient2) {
  {
    if (typeof reducePropsToState2 !== "function") {
      throw new Error("Expected reducePropsToState to be a function.");
    }
    if (typeof handleStateChangeOnClient2 !== "function") {
      throw new Error("Expected handleStateChangeOnClient to be a function.");
    }
  }
  function getDisplayName(WrappedComponent) {
    return WrappedComponent.displayName || WrappedComponent.name || "Component";
  }
  return function wrap(WrappedComponent) {
    {
      if (typeof WrappedComponent !== "function") {
        throw new Error("Expected WrappedComponent to be a React component.");
      }
    }
    const mountedInstances = [];
    let state;
    function emitChange() {
      state = reducePropsToState2(
        mountedInstances.map(function(instance) {
          return instance.props;
        })
      );
      handleStateChangeOnClient2(state);
    }
    const SideEffect = function(_PureComponent) {
      _inheritsLoose(SideEffect2, _PureComponent);
      function SideEffect2() {
        return _PureComponent.apply(this, arguments) || this;
      }
      SideEffect2.peek = function peek() {
        return state;
      };
      const _proto = SideEffect2.prototype;
      _proto.componentDidMount = function componentDidMount() {
        mountedInstances.push(this);
        emitChange();
      };
      _proto.componentDidUpdate = function componentDidUpdate() {
        emitChange();
      };
      _proto.componentWillUnmount = function componentWillUnmount() {
        const index = mountedInstances.indexOf(this);
        mountedInstances.splice(index, 1);
        emitChange();
      };
      _proto.render = function render() {
        return react.createElement(WrappedComponent, this.props);
      };
      return SideEffect2;
    }(react.PureComponent);
    _defineProperty(
      SideEffect,
      "displayName",
      "SideEffect(" + getDisplayName(WrappedComponent) + ")"
    );
    return SideEffect;
  };
}
var toArray = function(a) {
  const ret = Array(a.length);
  for (let i = 0; i < a.length; ++i) {
    ret[i] = a[i];
  }
  return ret;
};
var asArray = function(a) {
  return Array.isArray(a) ? a : [a];
};
var filterNested = function(nodes) {
  const contained = /* @__PURE__ */ new Set();
  const l = nodes.length;
  for (let i = 0; i < l; i += 1) {
    for (let j = i + 1; j < l; j += 1) {
      const position = nodes[i].compareDocumentPosition(nodes[j]);
      if ((position & Node.DOCUMENT_POSITION_CONTAINED_BY) > 0) {
        contained.add(j);
      }
      if ((position & Node.DOCUMENT_POSITION_CONTAINS) > 0) {
        contained.add(i);
      }
    }
  }
  return nodes.filter(function(_, index) {
    return !contained.has(index);
  });
};
var getTopParent = function(node) {
  return node.parentNode ? getTopParent(node.parentNode) : node;
};
var getAllAffectedNodes = function(node) {
  const nodes = asArray(node);
  return nodes.filter(Boolean).reduce(function(acc, currentNode) {
    const group = currentNode.getAttribute(FOCUS_GROUP);
    acc.push.apply(
      acc,
      group ? filterNested(
        toArray(
          getTopParent(currentNode).querySelectorAll(
            "[" + FOCUS_GROUP + '="' + group + '"]:not([' + FOCUS_DISABLED + '="disabled"])'
          )
        )
      ) : [currentNode]
    );
    return acc;
  }, []);
};
var isElementHidden = function(computedStyle) {
  if (!computedStyle || !computedStyle.getPropertyValue) {
    return false;
  }
  return computedStyle.getPropertyValue("display") === "none" || computedStyle.getPropertyValue("visibility") === "hidden";
};
var isVisible = function(node) {
  return !node || node === document || node && node.nodeType === Node.DOCUMENT_NODE || !isElementHidden(window.getComputedStyle(node, null)) && isVisible(
    node.parentNode && node.parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? node.parentNode.host : node.parentNode
  );
};
var notHiddenInput = function(node) {
  return !((node.tagName === "INPUT" || node.tagName === "BUTTON") && (node.type === "hidden" || node.disabled));
};
var isGuard = function(node) {
  return Boolean(node && node.dataset && node.dataset.focusGuard);
};
var isNotAGuard = function(node) {
  return !isGuard(node);
};
var isDefined = function(x) {
  return Boolean(x);
};
var tabSort = function(a, b) {
  const tabDiff = a.tabIndex - b.tabIndex;
  const indexDiff = a.index - b.index;
  if (tabDiff) {
    if (!a.tabIndex) {
      return 1;
    }
    if (!b.tabIndex) {
      return -1;
    }
  }
  return tabDiff || indexDiff;
};
var orderByTabIndex = function(nodes, filterNegative, keepGuards) {
  return toArray(nodes).map(function(node, index) {
    return {
      node,
      index,
      tabIndex: keepGuards && node.tabIndex === -1 ? (node.dataset || {}).focusGuard ? 0 : -1 : node.tabIndex
    };
  }).filter(function(data) {
    return !filterNegative || data.tabIndex >= 0;
  }).sort(tabSort);
};
var tabbables = [
  "button:enabled",
  "select:enabled",
  "textarea:enabled",
  "input:enabled",
  "a[href]",
  "area[href]",
  "summary",
  "iframe",
  "object",
  "embed",
  "audio[controls]",
  "video[controls]",
  "[tabindex]",
  "[contenteditable]",
  "[autofocus]"
];
var queryTabbables = tabbables.join(",");
var queryGuardTabbables = queryTabbables + ", [data-focus-guard]";
var getFocusables = function(parents, withGuards) {
  return parents.reduce(function(acc, parent) {
    return acc.concat(
      toArray(
        parent.querySelectorAll(
          withGuards ? queryGuardTabbables : queryTabbables
        )
      ),
      parent.parentNode ? toArray(parent.parentNode.querySelectorAll(queryTabbables)).filter(
        function(node) {
          return node === parent;
        }
      ) : []
    );
  }, []);
};
var getParentAutofocusables = function(parent) {
  const parentFocus = parent.querySelectorAll("[" + FOCUS_AUTO + "]");
  return toArray(parentFocus).map(function(node) {
    return getFocusables([node]);
  }).reduce(function(acc, nodes) {
    return acc.concat(nodes);
  }, []);
};
var filterFocusable = function(nodes) {
  return toArray(nodes).filter(function(node) {
    return isVisible(node);
  }).filter(function(node) {
    return notHiddenInput(node);
  });
};
var getTabbableNodes = function(topNodes, withGuards) {
  return orderByTabIndex(
    filterFocusable(getFocusables(topNodes, withGuards)),
    true,
    withGuards
  );
};
var getAllTabbableNodes = function(topNodes) {
  return orderByTabIndex(filterFocusable(getFocusables(topNodes)), false);
};
var parentAutofocusables = function(topNode) {
  return filterFocusable(getParentAutofocusables(topNode));
};
var getParents = function(node, parents) {
  if (parents === void 0) {
    parents = [];
  }
  parents.push(node);
  if (node.parentNode) {
    getParents(node.parentNode, parents);
  }
  return parents;
};
var getCommonParent = function(nodeA, nodeB) {
  const parentsA = getParents(nodeA);
  const parentsB = getParents(nodeB);
  for (let i = 0; i < parentsA.length; i += 1) {
    const currentParent = parentsA[i];
    if (parentsB.indexOf(currentParent) >= 0) {
      return currentParent;
    }
  }
  return false;
};
var getTopCommonParent = function(baseActiveElement, leftEntry, rightEntries) {
  const activeElements = asArray(baseActiveElement);
  const leftEntries = asArray(leftEntry);
  const activeElement = activeElements[0];
  let topCommon = false;
  leftEntries.filter(Boolean).forEach(function(entry) {
    topCommon = getCommonParent(topCommon || entry, entry) || topCommon;
    rightEntries.filter(Boolean).forEach(function(subEntry) {
      const common = getCommonParent(activeElement, subEntry);
      if (common) {
        if (!topCommon || common.contains(topCommon)) {
          topCommon = common;
        } else {
          topCommon = getCommonParent(common, topCommon);
        }
      }
    });
  });
  return topCommon;
};
var allParentAutofocusables = function(entries) {
  return entries.reduce(function(acc, node) {
    return acc.concat(parentAutofocusables(node));
  }, []);
};
var getFocusabledIn = function(topNode) {
  const entries = getAllAffectedNodes(topNode).filter(isNotAGuard);
  const commonParent = getTopCommonParent(topNode, topNode, entries);
  const outerNodes = getTabbableNodes([commonParent], true);
  const innerElements = getTabbableNodes(entries).filter(function(_a) {
    const node = _a.node;
    return isNotAGuard(node);
  }).map(function(_a) {
    const node = _a.node;
    return node;
  });
  return outerNodes.map(function(_a) {
    const node = _a.node, index = _a.index;
    return {
      node,
      index,
      lockItem: innerElements.indexOf(node) >= 0,
      guard: isGuard(node)
    };
  });
};
var focusInFrame = function(frame) {
  return frame === document.activeElement;
};
var focusInsideIframe = function(topNode) {
  return Boolean(
    toArray(topNode.querySelectorAll("iframe")).some(function(node) {
      return focusInFrame(node);
    })
  );
};
var focusInside = function(topNode) {
  const activeElement = document && document.activeElement;
  if (!activeElement || activeElement.dataset && activeElement.dataset.focusGuard) {
    return false;
  }
  return getAllAffectedNodes(topNode).reduce(function(result, node) {
    return result || node.contains(activeElement) || focusInsideIframe(node);
  }, false);
};
var focusIsHidden = function() {
  return document && toArray(document.querySelectorAll("[" + FOCUS_ALLOW + "]")).some(
    function(node) {
      return node.contains(document.activeElement);
    }
  );
};
var isRadio = function(node) {
  return node.tagName === "INPUT" && node.type === "radio";
};
var findSelectedRadio = function(node, nodes) {
  return nodes.filter(isRadio).filter(function(el) {
    return el.name === node.name;
  }).filter(function(el) {
    return el.checked;
  })[0] || node;
};
var correctNode = function(node, nodes) {
  if (isRadio(node) && node.name) {
    return findSelectedRadio(node, nodes);
  }
  return node;
};
var correctNodes = function(nodes) {
  const resultSet = /* @__PURE__ */ new Set();
  nodes.forEach(function(node) {
    return resultSet.add(correctNode(node, nodes));
  });
  return nodes.filter(function(node) {
    return resultSet.has(node);
  });
};
var pickFirstFocus = function(nodes) {
  if (nodes[0] && nodes.length > 1) {
    return correctNode(nodes[0], nodes);
  }
  return nodes[0];
};
var pickFocusable = function(nodes, index) {
  if (nodes.length > 1) {
    return nodes.indexOf(correctNode(nodes[index], nodes));
  }
  return index;
};
var NEW_FOCUS = "NEW_FOCUS";
var newFocus = function(innerNodes, outerNodes, activeElement, lastNode) {
  const cnt = innerNodes.length;
  const firstFocus = innerNodes[0];
  const lastFocus = innerNodes[cnt - 1];
  const isOnGuard = isGuard(activeElement);
  if (innerNodes.indexOf(activeElement) >= 0) {
    return void 0;
  }
  const activeIndex = outerNodes.indexOf(activeElement);
  const lastIndex = lastNode ? outerNodes.indexOf(lastNode) : activeIndex;
  const lastNodeInside = lastNode ? innerNodes.indexOf(lastNode) : -1;
  const indexDiff = activeIndex - lastIndex;
  const firstNodeIndex = outerNodes.indexOf(firstFocus);
  const lastNodeIndex = outerNodes.indexOf(lastFocus);
  const correctedNodes = correctNodes(outerNodes);
  const correctedIndexDiff = correctedNodes.indexOf(activeElement) - (lastNode ? correctedNodes.indexOf(lastNode) : activeIndex);
  const returnFirstNode = pickFocusable(innerNodes, 0);
  const returnLastNode = pickFocusable(innerNodes, cnt - 1);
  if (activeIndex === -1 || lastNodeInside === -1) {
    return NEW_FOCUS;
  }
  if (!indexDiff && lastNodeInside >= 0) {
    return lastNodeInside;
  }
  if (activeIndex <= firstNodeIndex && isOnGuard && Math.abs(indexDiff) > 1) {
    return returnLastNode;
  }
  if (activeIndex >= lastNodeIndex && isOnGuard && Math.abs(indexDiff) > 1) {
    return returnFirstNode;
  }
  if (indexDiff && Math.abs(correctedIndexDiff) > 1) {
    return lastNodeInside;
  }
  if (activeIndex <= firstNodeIndex) {
    return returnLastNode;
  }
  if (activeIndex > lastNodeIndex) {
    return returnFirstNode;
  }
  if (indexDiff) {
    if (Math.abs(indexDiff) > 1) {
      return lastNodeInside;
    }
    return (cnt + lastNodeInside + indexDiff) % cnt;
  }
  return void 0;
};
var findAutoFocused = function(autoFocusables) {
  return function(node) {
    return node.autofocus || node.dataset && !!node.dataset.autofocus || autoFocusables.indexOf(node) >= 0;
  };
};
var reorderNodes = function(srcNodes, dstNodes) {
  const remap = /* @__PURE__ */ new Map();
  dstNodes.forEach(function(entity) {
    return remap.set(entity.node, entity);
  });
  return srcNodes.map(function(node) {
    return remap.get(node);
  }).filter(isDefined);
};
var getFocusMerge = function(topNode, lastNode) {
  const activeElement = document && document.activeElement;
  const entries = getAllAffectedNodes(topNode).filter(isNotAGuard);
  const commonParent = getTopCommonParent(
    activeElement || topNode,
    topNode,
    entries
  );
  const anyFocusable = getAllTabbableNodes(entries);
  let innerElements = getTabbableNodes(entries).filter(function(_a) {
    const node = _a.node;
    return isNotAGuard(node);
  });
  if (!innerElements[0]) {
    innerElements = anyFocusable;
    if (!innerElements[0]) {
      return void 0;
    }
  }
  const outerNodes = getAllTabbableNodes([commonParent]).map(function(_a) {
    const node = _a.node;
    return node;
  });
  const orderedInnerElements = reorderNodes(outerNodes, innerElements);
  const innerNodes = orderedInnerElements.map(function(_a) {
    const node = _a.node;
    return node;
  });
  const newId = newFocus(innerNodes, outerNodes, activeElement, lastNode);
  if (newId === NEW_FOCUS) {
    const autoFocusable = anyFocusable.map(function(_a) {
      const node = _a.node;
      return node;
    }).filter(findAutoFocused(allParentAutofocusables(entries)));
    return {
      node: autoFocusable && autoFocusable.length ? pickFirstFocus(autoFocusable) : pickFirstFocus(innerNodes)
    };
  }
  if (newId === void 0) {
    return newId;
  }
  return orderedInnerElements[newId];
};
var focusOn = function(target) {
  target.focus();
  if ("contentWindow" in target && target.contentWindow) {
    target.contentWindow.focus();
  }
};
var guardCount = 0;
var lockDisabled = false;
var setFocus = function(topNode, lastNode) {
  const focusable = getFocusMerge(topNode, lastNode);
  if (lockDisabled) {
    return;
  }
  if (focusable) {
    if (guardCount > 2) {
      console.error(
        "FocusLock: focus-fighting detected. Only one focus management system could be active. See https://github.com/theKashey/focus-lock/#focus-fighting"
      );
      lockDisabled = true;
      setTimeout(function() {
        lockDisabled = false;
      }, 1);
      return;
    }
    guardCount++;
    focusOn(focusable.node);
    guardCount--;
  }
};
function deferAction(action2) {
  const _window = window, setImmediate = _window.setImmediate;
  if (typeof setImmediate !== "undefined") {
    setImmediate(action2);
  } else {
    setTimeout(action2, 1);
  }
}
var focusOnBody = function focusOnBody2() {
  return document && document.activeElement === document.body;
};
var isFreeFocus = function isFreeFocus2() {
  return focusOnBody() || focusIsHidden();
};
var lastActiveTrap = null;
var lastActiveFocus = null;
var lastPortaledElement = null;
var focusWasOutsideWindow = false;
var defaultWhitelist = function defaultWhitelist2() {
  return true;
};
var focusWhitelisted = function focusWhitelisted2(activeElement) {
  return (lastActiveTrap.whiteList || defaultWhitelist)(activeElement);
};
var recordPortal = function recordPortal2(observerNode, portaledElement) {
  lastPortaledElement = {
    observerNode,
    portaledElement
  };
};
var focusIsPortaledPair = function focusIsPortaledPair2(element) {
  return lastPortaledElement && lastPortaledElement.portaledElement === element;
};
function autoGuard(startIndex, end, step, allNodes) {
  let lastGuard = null;
  let i = startIndex;
  do {
    const item = allNodes[i];
    if (item.guard) {
      if (item.node.dataset.focusAutoGuard) {
        lastGuard = item;
      }
    } else if (item.lockItem) {
      if (i !== startIndex) {
        return;
      }
      lastGuard = null;
    } else {
      break;
    }
  } while ((i += step) !== end);
  if (lastGuard) {
    lastGuard.node.tabIndex = 0;
  }
}
var extractRef$1 = function extractRef(ref) {
  return ref && "current" in ref ? ref.current : ref;
};
var focusWasOutside = function focusWasOutside2(crossFrameOption) {
  if (crossFrameOption) {
    return Boolean(focusWasOutsideWindow);
  }
  return focusWasOutsideWindow === "meanwhile";
};
var activateTrap = function activateTrap2() {
  let result = false;
  if (lastActiveTrap) {
    const _lastActiveTrap = lastActiveTrap, observed = _lastActiveTrap.observed, persistentFocus = _lastActiveTrap.persistentFocus, autoFocus = _lastActiveTrap.autoFocus, shards = _lastActiveTrap.shards, crossFrame = _lastActiveTrap.crossFrame;
    const workingNode = observed || lastPortaledElement && lastPortaledElement.portaledElement;
    const activeElement = document && document.activeElement;
    if (workingNode) {
      const workingArea = [workingNode].concat(
        shards.map(extractRef$1).filter(Boolean)
      );
      if (!activeElement || focusWhitelisted(activeElement)) {
        if (persistentFocus || focusWasOutside(crossFrame) || !isFreeFocus() || !lastActiveFocus && autoFocus) {
          if (workingNode && !(focusInside(workingArea) || focusIsPortaledPair(activeElement))) {
            if (document && !lastActiveFocus && activeElement && !autoFocus) {
              if (activeElement.blur) {
                activeElement.blur();
              }
              document.body.focus();
            } else {
              result = setFocus(workingArea, lastActiveFocus);
              lastPortaledElement = {};
            }
          }
          focusWasOutsideWindow = false;
          lastActiveFocus = document && document.activeElement;
        }
      }
      if (document) {
        const newActiveElement = document && document.activeElement;
        const allNodes = getFocusabledIn(workingArea);
        const focusedIndex = allNodes.map(function(_ref2) {
          const node = _ref2.node;
          return node;
        }).indexOf(newActiveElement);
        if (focusedIndex > -1) {
          allNodes.filter(function(_ref2) {
            const guard = _ref2.guard, node = _ref2.node;
            return guard && node.dataset.focusAutoGuard;
          }).forEach(function(_ref3) {
            const node = _ref3.node;
            return node.removeAttribute("tabIndex");
          });
          autoGuard(focusedIndex, allNodes.length, 1, allNodes);
          autoGuard(focusedIndex, -1, -1, allNodes);
        }
      }
    }
  }
  return result;
};
var onTrap = function onTrap2(event) {
  if (activateTrap() && event) {
    event.stopPropagation();
    event.preventDefault();
  }
};
var onBlur = function onBlur2() {
  return deferAction(activateTrap);
};
var onFocus = function onFocus2(event) {
  const source = event.target;
  const currentNode = event.currentTarget;
  if (!currentNode.contains(source)) {
    recordPortal(currentNode, source);
  }
};
var FocusWatcher = function FocusWatcher2() {
  return null;
};
({
  children: propTypes$1.node.isRequired
});
var onWindowBlur = function onWindowBlur2() {
  focusWasOutsideWindow = "just";
  setTimeout(function() {
    focusWasOutsideWindow = "meanwhile";
  }, 0);
};
var attachHandler = function attachHandler2() {
  document.addEventListener("focusin", onTrap, true);
  document.addEventListener("focusout", onBlur);
  window.addEventListener("blur", onWindowBlur);
};
var detachHandler = function detachHandler2() {
  document.removeEventListener("focusin", onTrap, true);
  document.removeEventListener("focusout", onBlur);
  window.removeEventListener("blur", onWindowBlur);
};
function reducePropsToState(propsList) {
  return propsList.filter(function(_ref5) {
    const disabled = _ref5.disabled;
    return !disabled;
  });
}
function handleStateChangeOnClient(traps) {
  const trap = traps.slice(-1)[0];
  if (trap && !lastActiveTrap) {
    attachHandler();
  }
  const lastTrap = lastActiveTrap;
  const sameTrap = lastTrap && trap && trap.id === lastTrap.id;
  lastActiveTrap = trap;
  if (lastTrap && !sameTrap) {
    lastTrap.onDeactivation();
    if (!traps.filter(function(_ref6) {
      const id = _ref6.id;
      return id === lastTrap.id;
    }).length) {
      lastTrap.returnFocus(!trap);
    }
  }
  if (trap) {
    lastActiveFocus = null;
    if (!sameTrap || lastTrap.observed !== trap.observed) {
      trap.onActivation();
    }
    activateTrap();
    deferAction(activateTrap);
  } else {
    detachHandler();
    lastActiveFocus = null;
  }
}
mediumFocus.assignSyncMedium(onFocus);
mediumBlur.assignMedium(onBlur);
mediumEffect.assignMedium(function(cb) {
  return cb({
    moveFocusInside: setFocus,
    focusInside
  });
});
var FocusTrap = withSideEffect(
  reducePropsToState,
  handleStateChangeOnClient
)(FocusWatcher);
var FocusLockCombination = react.forwardRef(
  function FocusLockUICombination(props, ref) {
    return react.createElement(
      FocusLock,
      _extends$1(
        {
          sideCar: FocusTrap,
          ref
        },
        props
      )
    );
  }
);
var _ref = FocusLock.propTypes || {};
_ref.sideCar;
var propTypes = _objectWithoutPropertiesLoose$1(_ref, ["sideCar"]);
FocusLockCombination.propTypes = propTypes;
var __assign = function() {
  __assign = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (const p in s)
        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __rest(s, e) {
  const t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
var zeroRightClassName = "right-scroll-bar-position";
var fullWidthClassName = "width-before-scroll-bar";
var noScrollbarsClassName = "with-scroll-bars-hidden";
var removedBarSizeVariable = "--removed-body-scroll-bar-size";
var effectCar = createSidecarMedium();
var nothing = function() {
  return;
};
var RemoveScroll = react.forwardRef(function(props, parentRef) {
  const ref = react.useRef(null);
  const _a = react.useState({
    onScrollCapture: nothing,
    onWheelCapture: nothing,
    onTouchMoveCapture: nothing
  }), callbacks = _a[0], setCallbacks = _a[1];
  const forwardProps = props.forwardProps, children = props.children, className = props.className, removeScrollBar = props.removeScrollBar, enabled = props.enabled, shards = props.shards, sideCar = props.sideCar, noIsolation = props.noIsolation, inert = props.inert, allowPinchZoom = props.allowPinchZoom, _b = props.as, Container = _b === void 0 ? "div" : _b, rest = __rest(props, [
    "forwardProps",
    "children",
    "className",
    "removeScrollBar",
    "enabled",
    "shards",
    "sideCar",
    "noIsolation",
    "inert",
    "allowPinchZoom",
    "as"
  ]);
  const SideCar2 = sideCar;
  const containerRef = useMergeRefs([ref, parentRef]);
  const containerProps = __assign({}, rest, callbacks);
  return react.createElement(
    react.Fragment,
    null,
    enabled && react.createElement(SideCar2, {
      sideCar: effectCar,
      removeScrollBar,
      shards,
      noIsolation,
      inert,
      setCallbacks,
      allowPinchZoom: !!allowPinchZoom,
      lockRef: ref
    }),
    forwardProps ? react.cloneElement(
      react.Children.only(children),
      __assign({}, containerProps, { ref: containerRef })
    ) : react.createElement(
      Container,
      __assign({}, containerProps, {
        className,
        ref: containerRef
      }),
      children
    )
  );
});
RemoveScroll.defaultProps = {
  enabled: true,
  removeScrollBar: true,
  inert: false
};
RemoveScroll.classNames = {
  fullWidth: fullWidthClassName,
  zeroRight: zeroRightClassName
};
var getNonce = function() {
  if (typeof __webpack_nonce__ !== "undefined") {
    return __webpack_nonce__;
  }
  return void 0;
};
function makeStyleTag() {
  if (!document) return null;
  const tag = document.createElement("style");
  tag.type = "text/css";
  const nonce = getNonce();
  if (nonce) {
    tag.setAttribute("nonce", nonce);
  }
  return tag;
}
function injectStyles(tag, css) {
  if (tag.styleSheet) {
    tag.styleSheet.cssText = css;
  } else {
    tag.appendChild(document.createTextNode(css));
  }
}
function insertStyleTag(tag) {
  const head = document.head || document.getElementsByTagName("head")[0];
  head.appendChild(tag);
}
var stylesheetSingleton = function() {
  let counter = 0;
  let stylesheet = null;
  return {
    add: function(style) {
      if (counter == 0) {
        if (stylesheet = makeStyleTag()) {
          injectStyles(stylesheet, style);
          insertStyleTag(stylesheet);
        }
      }
      counter++;
    },
    remove: function() {
      counter--;
      if (!counter && stylesheet) {
        stylesheet.parentNode && stylesheet.parentNode.removeChild(stylesheet);
        stylesheet = null;
      }
    }
  };
};
var styleHookSingleton = function() {
  const sheet = stylesheetSingleton();
  return function(styles) {
    react.useEffect(function() {
      sheet.add(styles);
      return function() {
        sheet.remove();
      };
    }, []);
  };
};
var styleSingleton = function() {
  const useStyle = styleHookSingleton();
  const Sheet = function(_a) {
    const styles = _a.styles;
    useStyle(styles);
    return null;
  };
  return Sheet;
};
var zeroGap = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
};
var parse = function(x) {
  return parseInt(x || "", 10) || 0;
};
var getOffset = function(gapMode) {
  const cs = window.getComputedStyle(document.body);
  const left = cs[gapMode === "padding" ? "paddingLeft" : "marginLeft"];
  const top = cs[gapMode === "padding" ? "paddingTop" : "marginTop"];
  const right = cs[gapMode === "padding" ? "paddingRight" : "marginRight"];
  return [parse(left), parse(top), parse(right)];
};
var getGapWidth = function(gapMode) {
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  if (typeof window === "undefined") {
    return zeroGap;
  }
  const offsets = getOffset(gapMode);
  const documentWidth = document.documentElement.clientWidth;
  const windowWidth = window.innerWidth;
  return {
    left: offsets[0],
    top: offsets[1],
    right: offsets[2],
    gap: Math.max(0, windowWidth - documentWidth + offsets[2] - offsets[0])
  };
};
var Style = styleSingleton();
var getStyles = function(_a, allowRelative, gapMode, important) {
  const left = _a.left, top = _a.top, right = _a.right, gap = _a.gap;
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  return "\n  ." + noScrollbarsClassName + " {\n   overflow: hidden " + important + ";\n   padding-right: " + gap + "px " + important + ";\n  }\n  body {\n    overflow: hidden " + important + ";\n    " + [
    allowRelative && "position: relative " + important + ";",
    gapMode === "margin" && "\n    padding-left: " + left + "px;\n    padding-top: " + top + "px;\n    padding-right: " + right + "px;\n    margin-left:0;\n    margin-top:0;\n    margin-right: " + gap + "px " + important + ";\n    ",
    gapMode === "padding" && "padding-right: " + gap + "px " + important + ";"
  ].filter(Boolean).join("") + "\n  }\n  \n  ." + zeroRightClassName + " {\n    right: " + gap + "px " + important + ";\n  }\n  \n  ." + fullWidthClassName + " {\n    margin-right: " + gap + "px " + important + ";\n  }\n  \n  ." + zeroRightClassName + " ." + zeroRightClassName + " {\n    right: 0 " + important + ";\n  }\n  \n  ." + fullWidthClassName + " ." + fullWidthClassName + " {\n    margin-right: 0 " + important + ";\n  }\n  \n  body {\n    " + removedBarSizeVariable + ": " + gap + "px;\n  }\n";
};
var RemoveScrollBar = function(props) {
  const _a = react.useState(getGapWidth(props.gapMode)), gap = _a[0], setGap = _a[1];
  react.useEffect(
    function() {
      setGap(getGapWidth(props.gapMode));
    },
    [props.gapMode]
  );
  const noRelative = props.noRelative, noImportant = props.noImportant, _b = props.gapMode, gapMode = _b === void 0 ? "margin" : _b;
  return react.createElement(Style, {
    styles: getStyles(
      gap,
      !noRelative,
      gapMode,
      !noImportant ? "!important" : ""
    )
  });
};
var elementCouldBeVScrolled = function(node) {
  const styles = window.getComputedStyle(node);
  return styles.overflowY !== "hidden" && // not-not-scrollable
  !(styles.overflowY === styles.overflowX && styles.overflowY === "visible");
};
var elementCouldBeHScrolled = function(node) {
  const styles = window.getComputedStyle(node);
  return styles.overflowX !== "hidden" && // not-not-scrollable
  !(styles.overflowY === styles.overflowX && styles.overflowX === "visible");
};
var locationCouldBeScrolled = function(axis, node) {
  let current = node;
  do {
    const isScrollable = elementCouldBeScrolled(axis, current);
    if (isScrollable) {
      const _a = getScrollVariables(axis, current), s = _a[1], d = _a[2];
      if (s > d) {
        return true;
      }
    }
    current = current.parentNode;
  } while (current && current !== document.body);
  return false;
};
var getVScrollVariables = function(_a) {
  const scrollTop = _a.scrollTop, scrollHeight = _a.scrollHeight, clientHeight = _a.clientHeight;
  return [scrollTop, scrollHeight, clientHeight];
};
var getHScrollVariables = function(_a) {
  const scrollLeft = _a.scrollLeft, scrollWidth = _a.scrollWidth, clientWidth = _a.clientWidth;
  return [scrollLeft, scrollWidth, clientWidth];
};
var elementCouldBeScrolled = function(axis, node) {
  return axis === "v" ? elementCouldBeVScrolled(node) : elementCouldBeHScrolled(node);
};
var getScrollVariables = function(axis, node) {
  return axis === "v" ? getVScrollVariables(node) : getHScrollVariables(node);
};
var handleScroll = function(axis, endTarget, event, sourceDelta, noOverscroll) {
  const delta = sourceDelta;
  let target = event.target;
  const targetInLock = endTarget.contains(target);
  let shouldCancelScroll = false;
  const isDeltaPositive = delta > 0;
  let availableScroll = 0;
  let availableScrollTop = 0;
  do {
    const _a = getScrollVariables(axis, target), position = _a[0], scroll_1 = _a[1], capacity = _a[2];
    const elementScroll = scroll_1 - capacity - position;
    if (position || elementScroll) {
      if (elementCouldBeScrolled(axis, target)) {
        availableScroll += elementScroll;
        availableScrollTop += position;
      }
    }
    target = target.parentNode;
  } while (
    // portaled content
    !targetInLock && target !== document.body || // self content
    targetInLock && (endTarget.contains(target) || endTarget === target)
  );
  if (isDeltaPositive && (noOverscroll && availableScroll === 0 || !noOverscroll && delta > availableScroll)) {
    shouldCancelScroll = true;
  } else if (!isDeltaPositive && (noOverscroll && availableScrollTop === 0 || !noOverscroll && -delta > availableScrollTop)) {
    shouldCancelScroll = true;
  }
  return shouldCancelScroll;
};
var passiveSupported = false;
if (typeof window !== "undefined") {
  try {
    const options = Object.defineProperty({}, "passive", {
      get: function() {
        passiveSupported = true;
        return true;
      }
    });
    window.addEventListener("test", options, options);
    window.removeEventListener("test", options, options);
  } catch (err) {
    passiveSupported = false;
  }
}
var nonPassive = passiveSupported ? { passive: false } : false;
var getTouchXY = function(event) {
  return "changedTouches" in event ? [event.changedTouches[0].clientX, event.changedTouches[0].clientY] : [0, 0];
};
var getDeltaXY = function(event) {
  return [event.deltaX, event.deltaY];
};
var extractRef2 = function(ref) {
  return ref && "current" in ref ? ref.current : ref;
};
var deltaCompare = function(x, y) {
  return x[0] === y[0] && x[1] === y[1];
};
var generateStyle = function(id) {
  return "\n  .block-interactivity-" + id + " {pointer-events: none;}\n  .allow-interactivity-" + id + " {pointer-events: all;}\n";
};
var idCounter = 0;
var lockStack = [];
function RemoveScrollSideCar(props) {
  const shouldPreventQueue = react.useRef([]);
  const touchStartRef = react.useRef([0, 0]);
  const activeAxis = react.useRef();
  const id = react.useState(idCounter++)[0];
  const Style2 = react.useState(function() {
    return styleSingleton();
  })[0];
  const lastProps = react.useRef(props);
  react.useEffect(
    function() {
      lastProps.current = props;
    },
    [props]
  );
  react.useEffect(
    function() {
      if (props.inert) {
        document.body.classList.add("block-interactivity-" + id);
        const allow_1 = [props.lockRef.current].concat((props.shards || []).map(extractRef2)).filter(Boolean);
        allow_1.forEach(function(el) {
          return el.classList.add("allow-interactivity-" + id);
        });
        return function() {
          document.body.classList.remove("block-interactivity-" + id);
          allow_1.forEach(function(el) {
            return el.classList.remove("allow-interactivity-" + id);
          });
        };
      }
      return;
    },
    [props.inert, props.lockRef.current, props.shards]
  );
  const shouldCancelEvent = react.useCallback(function(event, parent) {
    if ("touches" in event && event.touches.length === 2) {
      return !lastProps.current.allowPinchZoom;
    }
    const touch = getTouchXY(event);
    const touchStart = touchStartRef.current;
    const deltaX = "deltaX" in event ? event.deltaX : touchStart[0] - touch[0];
    const deltaY = "deltaY" in event ? event.deltaY : touchStart[1] - touch[1];
    let currentAxis;
    const target = event.target;
    const moveDirection = Math.abs(deltaX) > Math.abs(deltaY) ? "h" : "v";
    let canBeScrolledInMainDirection = locationCouldBeScrolled(
      moveDirection,
      target
    );
    if (!canBeScrolledInMainDirection) {
      return true;
    }
    if (canBeScrolledInMainDirection) {
      currentAxis = moveDirection;
    } else {
      currentAxis = moveDirection === "v" ? "h" : "v";
      canBeScrolledInMainDirection = locationCouldBeScrolled(
        moveDirection,
        target
      );
    }
    if (!canBeScrolledInMainDirection) {
      return false;
    }
    if (!activeAxis.current && "changedTouches" in event && (deltaX || deltaY)) {
      activeAxis.current = currentAxis;
    }
    if (!currentAxis) {
      return true;
    }
    const cancelingAxis = activeAxis.current || currentAxis;
    return handleScroll(
      cancelingAxis,
      parent,
      event,
      cancelingAxis === "h" ? deltaX : deltaY,
      true
    );
  }, []);
  const shouldPrevent = react.useCallback(function(_event) {
    const event = _event;
    if (!lockStack.length || lockStack[lockStack.length - 1] !== Style2) {
      return;
    }
    const delta = "deltaY" in event ? getDeltaXY(event) : getTouchXY(event);
    const sourceEvent = shouldPreventQueue.current.filter(function(e) {
      return e.name === event.type && e.target === event.target && deltaCompare(e.delta, delta);
    })[0];
    if (sourceEvent && sourceEvent.should) {
      event.preventDefault();
      return;
    }
    if (!sourceEvent) {
      const shardNodes = (lastProps.current.shards || []).map(extractRef2).filter(Boolean).filter(function(node) {
        return node.contains(event.target);
      });
      const shouldStop = shardNodes.length > 0 ? shouldCancelEvent(event, shardNodes[0]) : !lastProps.current.noIsolation;
      if (shouldStop) {
        event.preventDefault();
      }
    }
  }, []);
  const shouldCancel = react.useCallback(function(name, delta, target, should) {
    const event = { name, delta, target, should };
    shouldPreventQueue.current.push(event);
    setTimeout(function() {
      shouldPreventQueue.current = shouldPreventQueue.current.filter(
        function(e) {
          return e !== event;
        }
      );
    }, 1);
  }, []);
  const scrollTouchStart = react.useCallback(function(event) {
    touchStartRef.current = getTouchXY(event);
    activeAxis.current = void 0;
  }, []);
  const scrollWheel = react.useCallback(function(event) {
    shouldCancel(
      event.type,
      getDeltaXY(event),
      event.target,
      shouldCancelEvent(event, props.lockRef.current)
    );
  }, []);
  const scrollTouchMove = react.useCallback(function(event) {
    shouldCancel(
      event.type,
      getTouchXY(event),
      event.target,
      shouldCancelEvent(event, props.lockRef.current)
    );
  }, []);
  react.useEffect(function() {
    lockStack.push(Style2);
    props.setCallbacks({
      onScrollCapture: scrollWheel,
      onWheelCapture: scrollWheel,
      onTouchMoveCapture: scrollTouchMove
    });
    document.addEventListener("wheel", shouldPrevent, nonPassive);
    document.addEventListener("touchmove", shouldPrevent, nonPassive);
    document.addEventListener("touchstart", scrollTouchStart, nonPassive);
    return function() {
      lockStack = lockStack.filter(function(inst) {
        return inst !== Style2;
      });
      document.removeEventListener("wheel", shouldPrevent, nonPassive);
      document.removeEventListener("touchmove", shouldPrevent, nonPassive);
      document.removeEventListener("touchstart", scrollTouchStart, nonPassive);
    };
  }, []);
  const removeScrollBar = props.removeScrollBar, inert = props.inert;
  return react.createElement(
    react.Fragment,
    null,
    inert ? react.createElement(Style2, { styles: generateStyle(id) }) : null,
    removeScrollBar ? react.createElement(RemoveScrollBar, { gapMode: "margin" }) : null
  );
}
var SideCar = exportSidecar(effectCar, RemoveScrollSideCar);
var ReactRemoveScroll = react.forwardRef(function(props, ref) {
  return react.createElement(
    RemoveScroll,
    __assign({}, props, { ref, sideCar: SideCar })
  );
});
ReactRemoveScroll.classNames = RemoveScroll.classNames;
function _extends() {
  _extends = Object.assign || function(target) {
    for (let i = 1; i < arguments.length; i++) {
      const source = arguments[i];
      for (const key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  const target = {};
  const sourceKeys = Object.keys(source);
  let key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var overlayPropTypes = {
  allowPinchZoom: propTypes$1.bool,
  dangerouslyBypassFocusLock: propTypes$1.bool,
  dangerouslyBypassScrollLock: propTypes$1.bool,
  // TODO:
  initialFocusRef: function initialFocusRef() {
    return null;
  },
  onDismiss: propTypes$1.func
};
var DialogOverlay = forwardRefWithAs(
  function DialogOverlay2(_ref2, forwardedRef) {
    const _ref$as = _ref2.as, Comp = _ref$as === void 0 ? "div" : _ref$as, _ref$isOpen = _ref2.isOpen, isOpen = _ref$isOpen === void 0 ? true : _ref$isOpen, props = _objectWithoutPropertiesLoose(_ref2, ["as", "isOpen"]);
    useCheckStyles("dialog");
    react.useEffect(
      function() {
        if (isOpen) {
          window.__REACH_DISABLE_TOOLTIPS = true;
        } else {
          window.requestAnimationFrame(function() {
            window.__REACH_DISABLE_TOOLTIPS = false;
          });
        }
      },
      [isOpen]
    );
    return isOpen ? react.createElement(
      Portal,
      {
        "data-reach-dialog-wrapper": ""
      },
      react.createElement(
        DialogInner,
        _extends(
          {
            ref: forwardedRef,
            as: Comp
          },
          props
        )
      )
    ) : null;
  }
);
{
  DialogOverlay.displayName = "DialogOverlay";
  DialogOverlay.propTypes = _extends({}, overlayPropTypes, {
    isOpen: propTypes$1.bool
  });
}
var DialogInner = forwardRefWithAs(
  function DialogInner2(_ref2, forwardedRef) {
    const allowPinchZoom = _ref2.allowPinchZoom, _ref2$as = _ref2.as, Comp = _ref2$as === void 0 ? "div" : _ref2$as, _ref2$dangerouslyBypa = _ref2.dangerouslyBypassFocusLock, dangerouslyBypassFocusLock = _ref2$dangerouslyBypa === void 0 ? false : _ref2$dangerouslyBypa, _ref2$dangerouslyBypa2 = _ref2.dangerouslyBypassScrollLock, dangerouslyBypassScrollLock = _ref2$dangerouslyBypa2 === void 0 ? false : _ref2$dangerouslyBypa2, initialFocusRef2 = _ref2.initialFocusRef, onClick = _ref2.onClick, _ref2$onDismiss = _ref2.onDismiss, onDismiss = _ref2$onDismiss === void 0 ? noop : _ref2$onDismiss, onKeyDown = _ref2.onKeyDown, onMouseDown = _ref2.onMouseDown, _ref2$unstable_lockFo = _ref2.unstable_lockFocusAcrossFrames, unstable_lockFocusAcrossFrames = _ref2$unstable_lockFo === void 0 ? true : _ref2$unstable_lockFo, props = _objectWithoutPropertiesLoose(_ref2, [
      "allowPinchZoom",
      "as",
      "dangerouslyBypassFocusLock",
      "dangerouslyBypassScrollLock",
      "initialFocusRef",
      "onClick",
      "onDismiss",
      "onKeyDown",
      "onMouseDown",
      "unstable_lockFocusAcrossFrames"
    ]);
    const mouseDownTarget = react.useRef(null);
    const overlayNode = react.useRef(null);
    const ref = useForkedRef(overlayNode, forwardedRef);
    const activateFocusLock = react.useCallback(
      function() {
        if (initialFocusRef2 && initialFocusRef2.current) {
          initialFocusRef2.current.focus();
        }
      },
      [initialFocusRef2]
    );
    function handleClick(event) {
      if (mouseDownTarget.current === event.target) {
        event.stopPropagation();
        onDismiss(event);
      }
    }
    function handleKeyDown(event) {
      if (event.key === "Escape") {
        event.stopPropagation();
        onDismiss(event);
      }
    }
    function handleMouseDown(event) {
      mouseDownTarget.current = event.target;
    }
    react.useEffect(function() {
      return overlayNode.current ? createAriaHider(overlayNode.current) : void 0;
    }, []);
    return react.createElement(
      FocusLockCombination,
      {
        autoFocus: true,
        returnFocus: true,
        onActivation: activateFocusLock,
        disabled: dangerouslyBypassFocusLock,
        crossFrame: unstable_lockFocusAcrossFrames
      },
      react.createElement(
        ReactRemoveScroll,
        {
          allowPinchZoom,
          enabled: !dangerouslyBypassScrollLock
        },
        react.createElement(
          Comp,
          _extends({}, props, {
            ref,
            "data-reach-dialog-overlay": "",
            /*
             * We can ignore the `no-static-element-interactions` warning here
             * because our overlay is only designed to capture any outside
             * clicks, not to serve as a clickable element itself.
             */
            onClick: wrapEvent(onClick, handleClick),
            onKeyDown: wrapEvent(onKeyDown, handleKeyDown),
            onMouseDown: wrapEvent(onMouseDown, handleMouseDown)
          })
        )
      )
    );
  }
);
{
  DialogOverlay.displayName = "DialogOverlay";
  DialogOverlay.propTypes = _extends({}, overlayPropTypes);
}
var DialogContent = forwardRefWithAs(
  function DialogContent2(_ref3, forwardedRef) {
    const _ref3$as = _ref3.as, Comp = _ref3$as === void 0 ? "div" : _ref3$as, onClick = _ref3.onClick;
    _ref3.onKeyDown;
    const props = _objectWithoutPropertiesLoose(_ref3, [
      "as",
      "onClick",
      "onKeyDown"
    ]);
    return react.createElement(
      Comp,
      _extends(
        {
          "aria-modal": "true",
          role: "dialog",
          tabIndex: -1
        },
        props,
        {
          ref: forwardedRef,
          "data-reach-dialog-content": "",
          onClick: wrapEvent(onClick, function(event) {
            event.stopPropagation();
          })
        }
      )
    );
  }
);
{
  DialogContent.displayName = "DialogContent";
  DialogContent.propTypes = {
    "aria-label": ariaLabelType,
    "aria-labelledby": ariaLabelType
  };
}
var Dialog = forwardRefWithAs(
  function Dialog2(_ref4, forwardedRef) {
    const _ref4$allowPinchZoom = _ref4.allowPinchZoom, allowPinchZoom = _ref4$allowPinchZoom === void 0 ? false : _ref4$allowPinchZoom, initialFocusRef2 = _ref4.initialFocusRef, isOpen = _ref4.isOpen, _ref4$onDismiss = _ref4.onDismiss, onDismiss = _ref4$onDismiss === void 0 ? noop : _ref4$onDismiss, props = _objectWithoutPropertiesLoose(_ref4, [
      "allowPinchZoom",
      "initialFocusRef",
      "isOpen",
      "onDismiss"
    ]);
    return react.createElement(
      DialogOverlay,
      {
        allowPinchZoom,
        initialFocusRef: initialFocusRef2,
        isOpen,
        onDismiss
      },
      react.createElement(
        DialogContent,
        _extends(
          {
            ref: forwardedRef
          },
          props
        )
      )
    );
  }
);
{
  Dialog.displayName = "Dialog";
  Dialog.propTypes = {
    isOpen: propTypes$1.bool,
    onDismiss: propTypes$1.func,
    "aria-label": ariaLabelType,
    "aria-labelledby": ariaLabelType
  };
}
function createAriaHider(dialogNode) {
  const originalValues = [];
  const rootNodes = [];
  const ownerDocument = getOwnerDocument(dialogNode);
  if (!dialogNode) {
    {
      console.warn(
        "A ref has not yet been attached to a dialog node when attempting to call `createAriaHider`."
      );
    }
    return noop;
  }
  Array.prototype.forEach.call(
    ownerDocument.querySelectorAll("body > *"),
    function(node) {
      let _dialogNode$parentNod, _dialogNode$parentNod2;
      const portalNode = (_dialogNode$parentNod = dialogNode.parentNode) == null ? void 0 : (_dialogNode$parentNod2 = _dialogNode$parentNod.parentNode) == null ? void 0 : _dialogNode$parentNod2.parentNode;
      if (node === portalNode) {
        return;
      }
      const attr = node.getAttribute("aria-hidden");
      const alreadyHidden = attr !== null && attr !== "false";
      if (alreadyHidden) {
        return;
      }
      originalValues.push(attr);
      rootNodes.push(node);
      node.setAttribute("aria-hidden", "true");
    }
  );
  return function() {
    rootNodes.forEach(function(node, index) {
      const originalValue = originalValues[index];
      if (originalValue === null) {
        node.removeAttribute("aria-hidden");
      } else {
        node.setAttribute("aria-hidden", originalValue);
      }
    });
  };
}
function ariaLabelType(props, propName, compName, location, propFullName) {
  const details = "\nSee https://www.w3.org/TR/wai-aria/#aria-label for details.";
  if (!props["aria-label"] && !props["aria-labelledby"]) {
    return new Error(
      "A <" + compName + "> must have either an `aria-label` or `aria-labelledby` prop.\n      " + details
    );
  }
  if (props["aria-label"] && props["aria-labelledby"]) {
    return new Error(
      "You provided both `aria-label` and `aria-labelledby` props to a <" + compName + ">. If the a label for this component is visible on the screen, that label's component should be given a unique ID prop, and that ID should be passed as the `aria-labelledby` prop into <" + compName + ">. If the label cannot be determined programmatically from the content of the element, an alternative label should be provided as the `aria-label` prop, which will be used as an `aria-label` on the HTML tag." + details
    );
  } else if (props[propName] != null && !isString(props[propName])) {
    return new Error(
      "Invalid prop `" + propName + "` supplied to `" + compName + "`. Expected `string`, received `" + (Array.isArray(propFullName) ? "array" : typeof propFullName) + "`."
    );
  }
  return null;
}
var dialog_default = Dialog;

// ../../node_modules/@ladle/react/lib/app/src/icons.tsx
var icons_exports = {};
__export(icons_exports, {
  A11y: () => A11y,
  Action: () => Action,
  Bulb: () => Bulb,
  Close: () => Close,
  Controls: () => Controls,
  Down: () => Down,
  Ladle: () => Ladle,
  Page: () => Page,
  Preview: () => Preview,
  Right: () => Right,
  Ring: () => Ring,
  Rtl: () => Rtl,
  Source: () => Source,
  Width: () => Width
});
var React2 = __toESM(require_react(), 1);
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var Close = () => {
  return (0, import_jsx_runtime.jsxs)(
    "svg",
    {
      width: 18,
      height: 18,
      viewBox: "0 0 24 24",
      strokeWidth: 2,
      stroke: "currentColor",
      fill: "none",
      strokeLinecap: "round",
      strokeLinejoin: "round",
      children: [
        (0, import_jsx_runtime.jsx)("path", { d: "M0 0h24v24H0z", stroke: "none" }),
        (0, import_jsx_runtime.jsx)("path", { d: "M18 6L6 18M6 6l12 12" })
      ]
    }
  );
};
var Ladle = () => {
  return (0, import_jsx_runtime.jsx)(
    "svg",
    {
      viewBox: "0 0 24 24",
      strokeWidth: 0.5,
      stroke: "currentColor",
      fill: "currentColor",
      width: 24,
      height: 24,
      children: (0, import_jsx_runtime.jsx)("path", { d: "M22 14H9V5a4 4 0 00-8 0v3a1 1 0 002 0V5a2 2 0 014 0v10a8 8 0 0016 0 1 1 0 00-1-1zm-7 7a6.01 6.01 0 01-5.917-5h11.834A6.01 6.01 0 0115 21z" })
    }
  );
};
var Rtl = () => {
  return (0, import_jsx_runtime.jsxs)(
    "svg",
    {
      width: 24,
      height: 24,
      viewBox: "0 0 24 24",
      strokeWidth: 2,
      stroke: "currentColor",
      fill: "none",
      strokeLinecap: "round",
      strokeLinejoin: "round",
      children: [
        (0, import_jsx_runtime.jsx)("path", { d: "M0 0h24v24H0z", stroke: "none" }),
        (0, import_jsx_runtime.jsx)("path", { d: "M16 4H9.5a3.5 3.5 0 000 7h.5M14 15V4M10 15V4M5 19h14M7 21l-2-2 2-2" })
      ]
    }
  );
};
var Ring = () => {
  React2.useEffect(() => {
    document.documentElement.removeAttribute("data-storyloaded");
    return () => document.documentElement.setAttribute("data-storyloaded", "");
  }, []);
  return (0, import_jsx_runtime.jsx)("div", { className: "ladle-ring-wrapper", children: (0, import_jsx_runtime.jsxs)("div", { className: "ladle-ring", children: [
    (0, import_jsx_runtime.jsx)("div", {}),
    (0, import_jsx_runtime.jsx)("div", {}),
    (0, import_jsx_runtime.jsx)("div", {}),
    (0, import_jsx_runtime.jsx)("div", {})
  ] }) });
};
var Preview = () => {
  const size = 24;
  const color = "currentColor";
  const stroke = 2;
  return (0, import_jsx_runtime.jsxs)(
    "svg",
    {
      width: size,
      height: size,
      viewBox: "0 0 24 24",
      strokeWidth: stroke,
      stroke: color,
      fill: "none",
      strokeLinecap: "round",
      strokeLinejoin: "round",
      children: [
        (0, import_jsx_runtime.jsx)("path", { d: "M0 0h24v24H0z", stroke: "none" }),
        (0, import_jsx_runtime.jsx)("path", { d: "M16 4h4v4M14 10l6-6M8 20H4v-4M4 20l6-6" })
      ]
    }
  );
};
var Bulb = () => {
  const size = 24;
  const color = "currentColor";
  const stroke = 2;
  return (0, import_jsx_runtime.jsxs)(
    "svg",
    {
      width: size,
      height: size,
      viewBox: "0 0 24 24",
      strokeWidth: stroke,
      stroke: color,
      fill: "none",
      strokeLinecap: "round",
      strokeLinejoin: "round",
      children: [
        (0, import_jsx_runtime.jsx)("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        (0, import_jsx_runtime.jsx)("path", { d: "M3 12h1m8 -9v1m8 8h1m-15.4 -6.4l.7 .7m12.1 -.7l-.7 .7" }),
        (0, import_jsx_runtime.jsx)("path", { d: "M9 16a5 5 0 1 1 6 0a3.5 3.5 0 0 0 -1 3a2 2 0 0 1 -4 0a3.5 3.5 0 0 0 -1 -3" }),
        (0, import_jsx_runtime.jsx)("line", { x1: 9.7, y1: 17, x2: 14.3, y2: 17 })
      ]
    }
  );
};
var Page = () => {
  return (0, import_jsx_runtime.jsx)(
    "div",
    {
      style: {
        width: "10px",
        marginInlineEnd: "0.5em",
        flexShrink: 0
      },
      children: (0, import_jsx_runtime.jsx)("svg", { fill: "currentColor", viewBox: "0 0 768 1024", children: (0, import_jsx_runtime.jsx)("path", { d: "M509 64l195 218v669q0 3-4 6t-9 3H77q-5 0-9-3t-4-6V73q0-3 4-6t9-3h432zm29-64H77Q45 0 22.5 21.5T0 73v878q0 30 22.5 51.5T77 1024h614q32 0 54.5-21.5T768 951V257zm-26 256V0h-64v256q0 26 19 45t45 19h253v-64H512z" }) })
    }
  );
};
var Down = ({ rotate }) => {
  const width = "16px";
  const height = "16px";
  return (0, import_jsx_runtime.jsx)(
    "div",
    {
      "aria-hidden": true,
      style: {
        width,
        height,
        marginInlineEnd: "0.1em"
      },
      children: rotate ? (0, import_jsx_runtime.jsxs)(
        "svg",
        {
          style: {
            width,
            height
          },
          viewBox: "0 0 24 24",
          stroke: "currentColor",
          fill: "none",
          children: [
            (0, import_jsx_runtime.jsx)("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
            (0, import_jsx_runtime.jsx)("path", { d: "M9 6l6 6l-6 6" })
          ]
        }
      ) : (0, import_jsx_runtime.jsxs)(
        "svg",
        {
          style: {
            width,
            height
          },
          viewBox: "0 0 24 24",
          stroke: "currentColor",
          fill: "none",
          children: [
            (0, import_jsx_runtime.jsx)("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
            (0, import_jsx_runtime.jsx)("path", { d: "M6 9l6 6l6 -6" })
          ]
        }
      )
    }
  );
};
var Right = () => {
  return (0, import_jsx_runtime.jsx)("div", { style: { width: "6px", marginInlineEnd: "0.65em" }, children: (0, import_jsx_runtime.jsx)("svg", { fill: "currentColor", viewBox: "0 0 574 1024", children: (0, import_jsx_runtime.jsx)("path", { d: "M10 9Q0 19 0 32t10 23l482 457L10 969Q0 979 0 992t10 23q10 9 24 9t24-9l506-480q10-10 10-23t-10-23L58 9Q48 0 34 0T10 9z" }) }) });
};
var Controls = () => {
  return (0, import_jsx_runtime.jsxs)(
    "svg",
    {
      width: 24,
      height: 24,
      viewBox: "0 0 24 24",
      strokeWidth: 2,
      stroke: "currentColor",
      fill: "none",
      children: [
        (0, import_jsx_runtime.jsx)("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        (0, import_jsx_runtime.jsx)("circle", { cx: 14, cy: 6, r: 2 }),
        (0, import_jsx_runtime.jsx)("line", { x1: 4, y1: 6, x2: 12, y2: 6 }),
        (0, import_jsx_runtime.jsx)("line", { x1: 16, y1: 6, x2: 20, y2: 6 }),
        (0, import_jsx_runtime.jsx)("circle", { cx: 8, cy: 12, r: 2 }),
        (0, import_jsx_runtime.jsx)("line", { x1: 4, y1: 12, x2: 6, y2: 12 }),
        (0, import_jsx_runtime.jsx)("line", { x1: 10, y1: 12, x2: 20, y2: 12 }),
        (0, import_jsx_runtime.jsx)("circle", { cx: 17, cy: 18, r: 2 }),
        (0, import_jsx_runtime.jsx)("line", { x1: 4, y1: 18, x2: 15, y2: 18 }),
        (0, import_jsx_runtime.jsx)("line", { x1: 19, y1: 18, x2: 20, y2: 18 })
      ]
    }
  );
};
var Source = () => {
  return (0, import_jsx_runtime.jsxs)(
    "svg",
    {
      width: 24,
      height: 24,
      viewBox: "0 0 24 24",
      strokeWidth: 2,
      stroke: "currentColor",
      fill: "none",
      strokeLinecap: "round",
      strokeLinejoin: "round",
      children: [
        (0, import_jsx_runtime.jsx)("path", { d: "M0 0h24v24H0z", stroke: "none" }),
        (0, import_jsx_runtime.jsx)("path", { d: "m7 8-4 4 4 4M17 8l4 4-4 4M14 4l-4 16" })
      ]
    }
  );
};
var A11y = () => (0, import_jsx_runtime.jsxs)(
  "svg",
  {
    width: 24,
    height: 24,
    strokeWidth: 2,
    viewBox: "0 0 24 24",
    stroke: "currentColor",
    fill: "none",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    children: [
      (0, import_jsx_runtime.jsx)("path", { d: "M0 0h24v24H0z", stroke: "none" }),
      (0, import_jsx_runtime.jsx)("circle", { cx: 12, cy: 12, r: 9 }),
      (0, import_jsx_runtime.jsx)("path", { d: "m10 16.5 2-3 2 3m-2-3v-2l3-1m-6 0 3 1" }),
      (0, import_jsx_runtime.jsx)("circle", { cx: 12, cy: 7.5, r: 0.5, fill: "currentColor" })
    ]
  }
);
var Width = () => (0, import_jsx_runtime.jsxs)(
  "svg",
  {
    width: 24,
    height: 24,
    strokeWidth: 2,
    viewBox: "0 0 24 24",
    stroke: "currentColor",
    fill: "none",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    children: [
      (0, import_jsx_runtime.jsx)("path", { d: "M0 0h24v24H0z", stroke: "none" }),
      (0, import_jsx_runtime.jsx)("rect", { x: 13, y: 8, width: 8, height: 12, rx: 1 }),
      (0, import_jsx_runtime.jsx)("path", { d: "M18 8V5a1 1 0 0 0-1-1H4a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1h9M16 9h2" })
    ]
  }
);
var Action = () => (0, import_jsx_runtime.jsxs)(
  "svg",
  {
    width: 24,
    height: 24,
    strokeWidth: 2,
    viewBox: "0 0 24 24",
    stroke: "currentColor",
    fill: "none",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    children: [
      (0, import_jsx_runtime.jsx)("path", { d: "M0 0h24v24H0z", stroke: "none" }),
      (0, import_jsx_runtime.jsx)("path", { d: "M18 8a3 3 0 0 1 0 6M10 8v11a1 1 0 0 1-1 1H8a1 1 0 0 1-1-1v-5" }),
      (0, import_jsx_runtime.jsx)("path", { d: "M12 8h0l4.524-3.77A.9.9 0 0 1 18 4.922v12.156a.9.9 0 0 1-1.476.692L12 14H4a1 1 0 0 1-1-1V9a1 1 0 0 1 1-1h8" })
    ]
  }
);

// ../../node_modules/@ladle/react/lib/app/src/ui.tsx
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var Button = ({
  children,
  onClick,
  style,
  ...rest
}) => {
  return (0, import_jsx_runtime2.jsx)(
    "button",
    {
      className: "ladle-button",
      onClick,
      style,
      "aria-label": rest["aria-label"],
      type: "button",
      children
    }
  );
};
var Link = ({
  children,
  href,
  style
}) => {
  return (0, import_jsx_runtime2.jsx)("a", { className: "ladle-link", href, style, children });
};
var Code = ({ children }) => {
  return (0, import_jsx_runtime2.jsx)("code", { className: "ladle-code", children });
};
var Modal = ({
  children,
  close,
  isOpen,
  label,
  maxWidth = "40em"
}) => {
  return (
    //@ts-ignore
    (0, import_jsx_runtime2.jsx)(
      DialogOverlay,
      {
        isOpen,
        onDismiss: () => close(),
        "data-testid": "ladle-dialog-overlay",
        children: (0, import_jsx_runtime2.jsxs)(
          DialogContent,
          {
            "aria-label": label || "Modal",
            "data-testid": "ladle-dialog",
            style: { maxWidth },
            children: [
              (0, import_jsx_runtime2.jsx)(
                "div",
                {
                  style: {
                    position: "absolute",
                    insetInlineEnd: "-6px",
                    top: "0px"
                  },
                  children: (0, import_jsx_runtime2.jsx)(
                    Button,
                    {
                      onClick: () => close(),
                      "aria-label": "Close modal",
                      style: {
                        height: "36px",
                        width: "36px",
                        borderColor: "transparent",
                        boxShadow: "none"
                      },
                      children: (0, import_jsx_runtime2.jsx)(Close, {})
                    }
                  )
                }
              ),
              (0, import_jsx_runtime2.jsx)("div", { className: "ladle-addon-modal-body", children })
            ]
          }
        )
      }
    )
  );
};

// ../../node_modules/@ladle/react/lib/app/exports.ts
var Story = (props) => props.children;
var Meta = (props) => props.children;
var Description = (props) => props.children;
var useLink = () => {
  const { dispatch } = useLadleContext();
  return (value) => dispatch({ type: "update-story" /* UpdateStory */, value });
};
var linkTo = (value) => {
  const dispatch = window.ladleDispatch;
  return () => dispatch({ type: "update-story" /* UpdateStory */, value });
};
var action = (name) => {
  const dispatch = window.ladleDispatch;
  return (event = void 0) => dispatch({
    type: "update-action" /* UpdateAction */,
    value: { name, event },
    clear: false
  });
};
export {
  ActionType,
  Description,
  Meta,
  ModeState,
  Story,
  ThemeState,
  action,
  dialog_exports as dialog,
  icons_exports as icons,
  linkTo,
  empty_module_exports as msw,
  ui_exports as ui,
  useLadleContext,
  useLink,
  useMDXComponents
};
/*! Bundled license information:

@ladle/react/lib/app/src/dialog.tsx:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)
*/
//# sourceMappingURL=@ladle_react.js.map
